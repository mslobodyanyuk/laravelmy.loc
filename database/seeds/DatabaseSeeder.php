<?phpuse Illuminate\Database\Seeder;class DatabaseSeeder extends Seeder {    /**     * Run the database seeds.     *     * @return void     */    public function run()    {        $this->call(MenusTableSeeder::class);        $this->call(BlogsTableSeeder::class);        $this->call(GalleriesTableSeeder::class);        $this->call(MyslidesTableSeeder::class);        $this->call(SlidesTableSeeder::class);        $this->call(TestsTableSeeder::class);        $this->call(UsersTableSeeder::class);	}}class MenusTableSeeder extends Seeder {    /**     * Run the database seeds.     *     * @return void     */    public function run()    {        DB::table('menus')->insert(['id' => 1, 'active' => 1, 'weight' => 1, 'title' => 'Home', 'url' => '/', 'position' => 'left', 'created_at' => '2015-07-22 09:03:58', 'updated_at' => '2015-08-29 06:34:34']);        DB::table('menus')->insert(['id' => 2, 'active' => 0, 'weight' => 2, 'title' => 'Projects', 'url' => '/projects', 'position' => 'left', 'created_at' => '2015-07-22 09:05:51', 'updated_at' => '2015-08-28 05:51:24']);        DB::table('menus')->insert(['id' => 3, 'active' => 0, 'weight' => 3, 'title' => 'About', 'url' => '/about-us', 'position' => 'left', 'created_at' => '2015-07-22 09:08:09', 'updated_at' => '2015-08-28 05:51:17']);        DB::table('menus')->insert(['id' => 4, 'active' => 1, 'weight' => 4, 'title' => 'Blog', 'url' => '/blog', 'position' => 'right', 'created_at' => '2015-07-22 09:09:08', 'updated_at' => '2015-07-22 09:09:08']);        DB::table('menus')->insert(['id' => 5, 'active' => 0, 'weight' => 5, 'title' => 'Press', 'url' => '/press', 'position' => 'right', 'created_at' => '2015-07-22 09:10:15', 'updated_at' => '2015-08-28 05:54:48']);        DB::table('menus')->insert(['id' => 6, 'active' => 0, 'weight' => 6, 'title' => 'Contact', 'url' => '/contact-us', 'position' => 'right', 'created_at' => '2015-07-22 09:11:20', 'updated_at' => '2015-08-28 05:54:57']);        DB::table('menus')->insert(['id' => 7, 'active' => 1, 'weight' => 2, 'title' => 'РЕЗЮМЕ', 'url' => '/uploads/resume/JuniorPHPDeveloper_SlobodyanyukMaksim.pdf', 'position' => 'left', 'created_at' => '2015-07-30 18:39:07', 'updated_at' => '2015-09-17 09:19:19']);        DB::table('menus')->insert(['id' => 8, 'active' => 1, 'weight' => 2, 'title' => 'ТЕСТОВОЕ ЗАДАНИЕ ModeraTest', 'url' => '/tests', 'position' => 'left', 'created_at' => '2015-08-20 12:28:50', 'updated_at' => '2015-08-25 13:41:44']);        DB::table('menus')->insert(['id' => 9, 'active' => 1, 'weight' => 5, 'title' => 'О СЕБЕ', 'url' => '/about-me', 'position' => 'right', 'created_at' => '2015-08-20 12:38:39', 'updated_at' => '2015-08-28 06:52:43']);        DB::table('menus')->insert(['id' => 10, 'active' => 1, 'weight' => 7, 'title' => 'КОНТАКТЫ', 'url' => '/contact-me', 'position' => 'right', 'created_at' => '2015-08-20 13:39:31', 'updated_at' => '2015-08-20 13:39:31']);        DB::table('menus')->insert(['id' => 11, 'active' => 0, 'weight' => 2, 'title' => 'TEST', 'url' => 'uploads\\resume\\TXT\\TXT.txt', 'position' => 'left', 'created_at' => '2015-11-23 08:44:23', 'updated_at' => '2015-11-23 09:18:15']);    }}class BlogsTableSeeder extends Seeder {    /**     * Run the database seeds.     *     * @return void     */    public function run()    {        DB::table('blogs')->insert(['id' => 1, 'active' => 1, 'title' => '1', 'slug' => '1', 'image' => 'ZtIFzNPLxdivbtHNEG2dqm9pElGb81xp.jpg', 'body' => '<h1>&nbsp;</h1><p>&quot;Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit...&quot;</p><p>&quot;Немає нікого, хто любив би самий біль, хто б шукав його чи хотів би його зазнавати тільки через те, що він - біль...&quot;</p>', 'created_at' => '2015-07-25 11:23:34', 'updated_at' => '2015-07-25 12:35:49']);        DB::table('blogs')->insert(['id' => 2, 'active' => 1, 'title' => '2', 'slug' => '2', 'image' => 'IUr4DpCfROZsPgLKPUmaCCLXBYKhdnMH.jpg', 'body' => '<h1><strong>Lorem Ipsum</strong></h1> - це текст-&quot;риба&quot;, що використовується в друкарстві та дизайні. Lorem Ipsum є, фактично, стандартною &quot;рибою&quot; аж з XVI сторіччя, коли невідомий друкар взяв шрифтову гранку та склав на ній підбірку зразків шрифтів. &quot;Риба&quot; не тільки успішно пережила п&#39;ять століть, але й прижилася в електронному верстуванні, залишаючись по суті незмінною. Вона популяризувалась в 60-их роках минулого сторіччя завдяки виданню зразків шрифтів Letraset, які містили уривки з Lorem Ipsum, і вдруге - нещодавно завдяки програмам комп&#39;ютерного верстування на кшталт Aldus Pagemaker, які використовували різні версії Lorem Ipsum.<p>&nbsp;</p>', 'created_at' => '2015-07-25 11:24:35', 'updated_at' => '2015-07-25 12:36:50']);        DB::table('blogs')->insert(['id' => 3, 'active' => 1, 'title' => '3', 'slug' => '3', 'image' => 'I4xh2NivDVJ2MFrAkpKEFZHr54sUlMYS.jpg', 'body' => '<p>На відміну від поширеної думки Lorem Ipsum не є випадковим набором літер. Він походить з уривку класичної латинської літератури 45 року до н.е., тобто має більш як 2000-річну історію. Річард Макклінток, професор латини з коледжу Хемпдін-Сидні, що у Вірджінії, вивчав одне з найменш зрозумілих латинських слів - consectetur - з уривку Lorem Ipsum, і у пошуку цього слова в класичній літературі знайшов безсумнівне джерело. Lorem Ipsum походить з розділів 1.10.32 та 1.10.33 цицеронівського &quot;de Finibus Bonorum et Malorum&quot; (&quot;Про межі добра і зла&quot;), написаного у 45 році до н.е. Цей трактат з теорії етики був дуже популярним в епоху Відродження. Перший рядок Lorem Ipsum, &quot;Lorem ipsum dolor sit amet...&quot; походить з одного з рядків розділу 1.10.32.</p><p>Класичний текст, використовуваний з XVI сторіччя, наведено нижче для всіх зацікавлених. Також точно за оригіналом наведено розділи 1.10.32 та 1.10.33 цицеронівського &quot;de Finibus Bonorum et Malorum&quot; разом із перекладом англійською, виконаним 1914 року Х.Рекемом.</p>', 'created_at' => '2015-07-25 11:25:48', 'updated_at' => '2015-07-25 12:37:32']);        DB::table('blogs')->insert(['id' => 4, 'active' => 1, 'title' => '4', 'slug' => '4', 'image' => 'Nn5Xs0cGbO5Ok6h9v9Qv36lWcHfz5q3d.jpg', 'body' => '<p>Вже давно відомо, що читабельний зміст буде заважати зосередитись людині, яка оцінює композицію сторінки. Сенс використання Lorem Ipsum полягає в тому, що цей текст має більш-менш нормальне розподілення літер на відміну від, наприклад, &quot;Тут іде текст. Тут іде текст.&quot; Це робить текст схожим на оповідний. Багато програм верстування та веб-дизайну використовують Lorem Ipsum як зразок і пошук за терміном &quot;lorem ipsum&quot; відкриє багато веб-сайтів, які знаходяться ще в зародковому стані. Різні версії Lorem Ipsum з&#39;явились за минулі роки, деякі випадково, деякі було створено зумисно (зокрема, жартівливі).</p><p>Класичний текст, використовуваний з XVI сторіччя, наведено нижче для всіх зацікавлених. Також точно за оригіналом наведено розділи 1.10.32 та 1.10.33 цицеронівського &quot;de Finibus Bonorum et Malorum&quot; разом із перекладом англійською, виконаним 1914 року Х.Рекемом.</p>', 'created_at' => '2015-07-25 11:26:38', 'updated_at' => '2015-07-25 12:38:16']);        DB::table('blogs')->insert(['id' => 5, 'active' => 1, 'title' => 'record5', 'slug' => '5', 'image' => 'CsT4nNazIucfoWt0R4EQ78RZGHorm8qT.jpg', 'body' => '<p>Існує багато варіацій уривків з Lorem Ipsum, але більшість з них зазнала певних змін на кшталт жартівливих вставок або змішування слів, які навіть не виглядають правдоподібно. Якщо ви збираєтесь використовувати Lorem Ipsum, ви маєте упевнитись в тому, що всередині тексту не приховано нічого, що могло б викликати у читача конфуз. Більшість відомих генераторів Lorem Ipsum в Мережі генерують текст шляхом повторення наперед заданих послідовностей Lorem Ipsum. Принципова відмінність цього генератора робить його першим справжнім генератором Lorem Ipsum. Він використовує словник з більш як 200 слів латини та цілий набір моделей речень - це дозволяє генерувати Lorem Ipsum, який виглядає осмислено. Таким чином, згенерований Lorem Ipsum не міститиме повторів, жартів, нехарактерних для латини слів і т.ін.</p>', 'created_at' => '2015-07-25 11:28:03', 'updated_at' => '2015-07-25 15:27:36']);        DB::table('blogs')->insert(['id' => 6, 'active' => 1, 'title' => 'record6', 'slug' => '6', 'image' => 'gr4EiAmNJy3oXbYtKNbK06I41V401Weg.jpg', 'body' => '<h3>Стандартний Lorem Ipsum, використовуваний з XVI ст.</h3><p>&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&quot;</p><h3>Розділ 1.10.32 &quot;de Finibus Bonorum et Malorum&quot;, написаного Цицероном у 45 році до н.е.</h3><p>&quot;Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?&quot;</p>', 'created_at' => '2015-07-25 11:34:37', 'updated_at' => '2015-07-25 15:26:31']);   }}class GalleriesTableSeeder extends Seeder {    /**     * Run the database seeds.     *     * @return void     */    public function run()    {        DB::table('galleries')->insert(['id' => 1, 'project_id' => 1, 'active' => 1, 'weight' => 1, 'image' => 'diVDq10iqPHW7nsfogzDRIXdx0y6eh4P.jpg', 'alt' => 'image', 'title' => 'image', 'created_at' => '2015-07-24 08:57:27', 'updated_at' => '2015-07-24 08:57:59']);        DB::table('galleries')->insert(['id' => 2, 'project_id' => 1, 'active' => 1, 'weight' => 2, 'image' => 'Npb0nkWUAk3EFKe7h1LmzfavsLRIYNMT.jpg', 'alt' => 'test', 'title' => 'test', 'created_at' => '2015-07-24 08:58:33', 'updated_at' => '2015-07-24 08:58:33']);        DB::table('galleries')->insert(['id' => 3, 'project_id' => 1, 'active' => 1, 'weight' => 3, 'image' => 'Jk2OEsIrK5dpnfMqlko3cICUwwjnmVZ2.png', 'alt' => 'asdasda', 'title' => 'asdad', 'created_at' => '2015-07-24 08:59:17', 'updated_at' => '2015-07-24 08:59:17']);        DB::table('galleries')->insert(['id' => 4, 'project_id' => 2, 'active' => 1, 'weight' => 1, 'image' => '4BSahvOXtV4WS5zz8dNLmSE870MGPz1h.jpg', 'alt' => 'sdfs', 'title' => 'sdsd', 'created_at' => '2015-07-24 09:01:31', 'updated_at' => '2015-07-24 09:01:31']);    }}class MyslidesTableSeeder extends Seeder {    /**     * Run the database seeds.     *     * @return void     */    public function run()    {        DB::table('myslides')->insert(['id' => 1, 'active' => 0, 'weight' => 1, 'image' => 'RXIiOSivn6AmIG95QmUlmD0kONa18HqT.png', 'created_at' => '2015-08-29 06:10:00', 'updated_at' => '2015-09-17 11:51:01']);        DB::table('myslides')->insert(['id' => 2, 'active' => 1, 'weight' => 2, 'image' => 'kjaEosfGZwoGzapBZeI1zI1llWzo8mnd.png', 'created_at' => '2015-08-29 06:10:30', 'updated_at' => '2015-08-29 06:10:30']);        DB::table('myslides')->insert(['id' => 5, 'active' => 1, 'weight' => 4, 'image' => 'hWJtG0G04naoYRiDNmNODKUUhw6Ziy86.png', 'created_at' => '2015-09-08 07:34:46', 'updated_at' => '2015-09-08 07:34:46']);        DB::table('myslides')->insert(['id' => 6, 'active' => 1, 'weight' => 1, 'image' => '59jGywHAP342uHgMQa8gL8t8IvmGmWe0.png', 'created_at' => '2015-09-17 11:42:05', 'updated_at' => '2015-09-17 11:48:58']);    }}class SlidesTableSeeder extends Seeder {    /**     * Run the database seeds.     *     * @return void     */    public function run()    {        DB::table('slides')->insert(['id' => 1, 'active' => 1, 'weight' => 1, 'image' => 'Itw4NWCHuxZgGjQQfqHu8xRHjeqAqoQk.png', 'created_at' => '2015-07-23 13:06:46', 'updated_at' => '2015-07-23 13:35:27']);        DB::table('slides')->insert(['id' => 2, 'active' => 1, 'weight' => 2, 'image' => 'JiR9YkXTzaEoShFPdUv9W9jQkE04EmRS.jpg', 'created_at' => '2015-07-23 13:08:24', 'updated_at' => '2015-07-23 13:08:24']);        DB::table('slides')->insert(['id' => 3, 'active' => 1, 'weight' => 3, 'image' => 'DgsHpuBCp0PtARIwsDixRJgoweZfFTBP.jpg', 'created_at' => '2015-07-23 13:08:51', 'updated_at' => '2015-07-23 13:08:51']);    }}class TestsTableSeeder extends Seeder {    /**     * Run the database seeds.     *     * @return void     */    public function run()    {            $content = str_replace(array('\r\n', '\n', '\r'), "\n" ,'<p>We have a text file with structured tree information in form of:<br />\n&nbsp; &nbsp;node_id|parent_id|node_name<br />\n&nbsp; &nbsp;node_id: numeric node id<br />\n&nbsp; &nbsp;parent_id: id of parent node</p>\n\n<p>Main task is to represent this tree with correct paddings for every level,<br />\nlevel one - zero paddings, level two - one padding and so on.</p>\n\n<p>Try to write code as simple as possible and we want to see high performance solution<br />\n---------------------------------------------------------------------------<br />\nInput data:<br />\n1|0|Electronics<br />\n2|0|Video<br />\n3|0|Photo<br />\n4|1|MP3 player<br />\n5|1|TV<br />\n6|4|iPod<br />\n7|6|Shuffle<br />\n8|3|SLR<br />\n9|8|DSLR<br />\n10|9|Nikon<br />\n11|9|Canon<br />\n12|11|20D<br />\n----------------------------------------------------------------------------<br />\n---<br />\nOutput data:<br />\nElectronics<br />\n-MP3 player<br />\n--iPod<br />\n---Shuffle<br />\n-TV<br />\nVideo<br />\nPhoto<br />\n-SLR<br />\n--DSLR<br />\n---Nikon<br />\n---Canon<br />\n----20D</p>\n');        DB::table('tests')->insert(['id' => 1, 'active' => 1, 'title' => '1. Задание, task_en.txt', 'slug' => 'task_en', 'image' => '8Z9ENcblwFnJFSzHZywikjXTsHukG4Wx.png', 'content' => $content , 'created_at' => '2015-08-25 11:18:32', 'updated_at' => '2015-09-23 09:21:03']);            $content = str_replace(array('\r\n', '\n', '\r'), "\n" ,'<p>У нас есть текстовый файл со структурированной информацией дерева в виде:<br />\nnode_id | parent_id | node_name<br />\nnode_id: числовой идентификатор узла<br />\nparent_id: идентификатор родительского узла</p>\n\n<p>Главная задача состоит в том, чтобы представить это дерево с правильным колличеством разделителей &quot;|&quot; для каждого уровня,<br />\nодин уровень - нет разделителей, два уровня - один разделитель и так далее.</p>\n\n<p>Попробуйте написать код как можно более простым, и мы хотим увидеть High Performance решение.<br />\n---------------------------------------------------------------------------<br />\nВходные данные:<br />\n1 | 0 | Электроника<br />\n2 | 0 | Видео<br />\n3 | 0 | Фото<br />\n4 | 1 | MP3-плеер<br />\n5 | 1 | ТВ<br />\n6 | 4 | Ipod<br />\n7 | 6 | Shuffle<br />\n8 | 3 | SLR<br />\n9 | 8 | DSLR<br />\n10 | 9 | Nikon<br />\n11 | 9 | Canon<br />\n12 | 11 | 20D<br />\n----------------------------------------------------------------------------<br />\n---<br />\nВыходные данные:<br />\nЭлектроника<br />\n-MP3 Игрок<br />\n--iPod<br />\n--- Shuffle<br />\n-TV<br />\nВидео<br />\nФото<br />\n-SLR<br />\n--DSLR<br />\n--- Nikon<br />\n--- Canon<br />\n---- 20D</p>\n');        DB::table('tests')->insert(['id' => 2, 'active' => 1, 'title' => '1.1 Задание, task_ru.txt', 'slug' => 'task_ru', 'image' => 'tWI3KZ49KgQL9m1o3IHrBnd2gCmyfVXZ.png', 'content' => $content , 'created_at' => '2015-08-25 11:19:47', 'updated_at' => '2015-09-24 05:55:22']);            $content = str_replace(array('\r\n', '\n', '\r'), "\n" , '<p>Для этого задания нужно использовать Паттерны проектирования. Компоновщик (composite)<br />\nв лоб там не пройдёт:<br />\n&nbsp;composite + iterator<br />\n&nbsp;&nbsp; &nbsp;composite - хранит структурку&nbsp;<br />\n&nbsp;&nbsp; &nbsp;iterator - управляет структуркой<br />\n(composite) из группы структурирующих.<br />\niterator - поведенческий.</p>\n\n<p>Тут конечно и фабрику можно прикрутить для создания объектов, паттерны фабрик - порождающие.</p>\n\n<p>схема такая:<br />\n&nbsp;&nbsp; &nbsp;1. читаешь данные<br />\n&nbsp;&nbsp; &nbsp;2. создаешь объект<br />\n&nbsp;&nbsp; &nbsp;3. добавляешь в сущьность composite при помощи iterator<br />\n&nbsp;&nbsp; &nbsp;4. печатаешь результат тоже при помощи итератора</p>\n\n<p>Компоновщик - это хранилище данных (типа массива).<br />\nИтератор - класс, который умеет и делает манипуляции с компоновщиком.&nbsp;<br />\nФайл читать тебе нужно другим классом, и нужен парсер данных из файла в массив например.</p>\n\n<p>логика такая:<br />\n1. Класс File(ты должен реализовать) читает файл и возвращает массив.<br />\n&nbsp;&nbsp; &nbsp;(читает файл отдает содержимое парсеру тот возвращает массив)<br />\n2. Фабрика создает из массива Компоновщик(группа классов. см. доку.)<br />\n3. Итератор умеет перебирать компоновщик, и при помощи него выводится дерево, ну эти фун-и можно использовать внутри парсера файла.<br />\nПарсер - класс, преобразования данных (например из текста в массив).&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp;&nbsp; &nbsp;$file = new File($pathToFile)<br />\n&nbsp;&nbsp; &nbsp;$text = $file-&gt;getContent();</p>\n\n<p>&nbsp;&nbsp; &nbsp;$parcer = new TextParcer();<br />\n&nbsp;&nbsp; &nbsp;$dataArray = $parcer-&gt;parce($text);</p>\n\n<p>&nbsp;&nbsp; &nbsp;$factory = new CompositeFactory();<br />\n&nbsp;&nbsp; &nbsp;$composite = new Composite();<br />\n&nbsp;&nbsp; &nbsp;$iterator = new Iterator($composite);<br />\n&nbsp;&nbsp; &nbsp;foreach ($dataArray as $row ) {<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;...<br />\n&nbsp;&nbsp; &nbsp;}</p>\n\n<p>&nbsp;</p>\n\n<p>В файле для этого примера будет 2 метода getContent() и write()<br />\nwrite()- заполняет файл задания</p>\n\n<p>&nbsp;&nbsp; &nbsp;private $pathToFile; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public function __construct($path){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this -&gt;pathToFile = $path;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;$this -&gt;pathToFile = &#39;write.txt&#39; &nbsp;- bad smells.<br />\nПрисваивать название файла в конструкторе, как я выше показал:&nbsp;<br />\n&nbsp;&nbsp; &nbsp;public function __construct($path){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this -&gt;pathToFile = $path;<br />\n&nbsp;&nbsp; &nbsp;}<br />\nПри создании обьекта конструктору передавать имя файла, передается полный путь к нему+имя файла pathToFile:<br />\n&nbsp;&nbsp; &nbsp;$file = new File($pathToFil);<br />\n&nbsp;&nbsp; &nbsp;$file2 = new File($pathToFile2);<br />\n&nbsp;&nbsp; &nbsp;$file2 - объект в который нужно писать результат.</p>\n\n<p><br />\nВ том, что я тебе написал тебе нужно реализовать &nbsp;File, TextParser, CompositeFactory, Composite, Iterator.</p>\n\n<p>/************************ФОРМА*************************************************************/<br />\nСмотри, как я вижу. Тебе нужно сделать визуальную часть. Формочка которая запрашивает файл,<br />\nзагружает его, парсит, выводит на экран результат.<br />\n/************************ФОРМА*************************************************************/</p>\n\n<p><br />\nВсе классы должны лежать на уровень выше чем \\public. В паблике только точка входа, это для безопастности.</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/***route.yml***/<br />\n1. Создай роут конфиг файл типа(yml). положи его в конфиг<br />\n&nbsp;&nbsp; &nbsp;index: &nbsp; &nbsp; [/, IndexController.indexAction]<br />\n&nbsp;&nbsp; &nbsp;upload: &nbsp;[/upload, IndexController.uploadAction]<br />\n&nbsp;&nbsp; &nbsp;...</p>\n\n<p>2. Создай класс Rout c методом&nbsp;<br />\n&nbsp;&nbsp; &nbsp;__construct(array $config) - $config - данные из файла<br />\n&nbsp;&nbsp; &nbsp;match($url) - созвращает array(&#39;controller&#39; =&gt; &#39;контроллер&#39;, &#39;action&#39; =&gt; &#39;метод&#39;)</p>\n\n<p>3. Класс kernel синглетон. В котром загружаешь конфиг, передаешь в роутер, получаешь данные по контроллеру,<br />\n&nbsp;&nbsp; &nbsp;выполняешь метод нужного контроллера получаешь результат выполнения,<br />\n&nbsp;&nbsp; &nbsp;Kernel<br />\n&nbsp;&nbsp; &nbsp;render($params)<br />\n&nbsp;&nbsp; &nbsp;{<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;выпоняет отображение результата работы&nbsp;<br />\n&nbsp;&nbsp; &nbsp;}</p>\n\n<p><br />\n1. Тебе нужно вычитать route.yml преобразовать его в масив и передать в конструктор роутера<br />\n&nbsp;&nbsp; &nbsp;Дальше написать метод match($url) который тебе вернет нужные параметры. По ним получить контроллер и метод и выполнить их роутера = Rout.</p>\n\n<p>&nbsp;&nbsp; &nbsp;Вычитать route.yml преобразовать его в масив и передать в конструктор роутера это выполняется в кернеле, Kernel.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n2. Создай класс Rout c методом&nbsp;<br />\n__construct(array $config) - $config - данные из файла<br />\nmatch($url) - возвращает array(&#39;controller&#39; =&gt; &#39;контроллер&#39;, &#39;action&#39; =&gt; &#39;метод&#39;) ,&nbsp;<br />\n&nbsp;&nbsp; &nbsp;у роута 2 метода , конструктор, и match($url)<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/***route.yml***/</p>\n\n<p>Конструктор &nbsp;- &nbsp;__construct(array $config) получает уже массив. match($url) - &nbsp;возвращает array(&#39;controller&#39; =&gt; &#39;контроллер&#39;, &#39;action&#39; =&gt; &#39;метод&#39;)<br />\nВычитку сделай в кернеле метод, readConfigs.</p>\n\n<p><br />\nСделай еще одну папку на одном уровне с src и назови ее app, в аpp 2 папки с соотв-щими классами.<br />\nЗаменяем хардкод, что уже есть в public/app.php /* Пути по-умолчанию для поиска файлов */</p>\n\n<p><br />\nНеобходимо установить COMPOSER.(Установка COMPOSER.)</p>\n\n<p><br />\n1. В браузере вбиваешь адресс modera.loc/<br />\n&nbsp;&nbsp; &nbsp;2. выполняется скрипт файла app.php<br />\n&nbsp;&nbsp; &nbsp;2.1 Инициализация кернел - в котором читается конфиг роутинга<br />\n&nbsp;&nbsp; &nbsp;2.2 запускаем просес с параметрами из конфига роутинга&nbsp;<br />\n&nbsp;&nbsp; &nbsp;[ &nbsp;[&quot;controller&quot;]=&gt; &nbsp;&quot;src\\Controller\\IndexController&quot;, &nbsp;[&quot;action&quot;]=&gt;&quot;indexAction&quot;]]<br />\n&nbsp;&nbsp; &nbsp;в котором создаем объект контроллера и выполняем его метод indexAction<br />\n&nbsp;&nbsp; &nbsp;Метод контроллера выполняет действия и как результат работы возвращает массив данных, который мы передадим в рендер.<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;<br />\n&nbsp;У тебя есть страница отображения каталога товаров &nbsp;абстрактный пример:<br />\n&nbsp;&nbsp; &nbsp;Page 1 (some text ... )<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;|id|name|price|<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(some text)<br />\n&nbsp;&nbsp; &nbsp;Для отображения данной страницы. Контроллер выбирает данные из БД/файла/или др. источника и возвращает массив вида<br />\n&nbsp;&nbsp; &nbsp;[<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[&#39;id&#39; =&gt;1, &#39;name&#39;=&gt;&#39;HDD&#39;, &#39;price&#39;=&gt;250],<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[&#39;id&#39; =&gt;2, &#39;name&#39;=&gt;&#39;SSD&#39;, &#39;price&#39;=&gt;550],<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;...<br />\n&nbsp;&nbsp; &nbsp;]&nbsp;&nbsp; &nbsp;</p>\n\n<p><br />\n&nbsp;&nbsp; &nbsp;<br />\n/**************/<br />\n&nbsp;&nbsp; &nbsp;Если ненужны данные то контроллер пустой и возвращает ничего.<br />\n/**************/&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Конфиги, контроллеры, вьюшки.<br />\nПо каждой из ссылок должна отработать цепочка из таблицы, эту таблицу можно дополнять новыми урлами, но функцию process и render после написания&nbsp;<br />\nты больше не трогаешь и вообще kernel не трогаешь. Настраиваешь все конфигами и, если нужно, пишешь контроллеры с вьюшками.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\nесли ты поставишь&nbsp;<br />\nurl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| modera_test.loc/index &nbsp; | modera_test.loc/upload &nbsp; &nbsp;| modera_test.loc/list<br />\ncontroller &nbsp; &nbsp; | Index &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | FileProcessController &nbsp; &nbsp; | FileProcessController<br />\nmethod &nbsp; &nbsp; &nbsp; &nbsp; | indexAction() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | uploadAction() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| listAction()<br />\nview &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | index.php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | upload.php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| list.php<br />\nто &nbsp;FileProcessController ты возмешь из $routeParams при заходе на урлу modera_test.loc/upload</p>\n\n<p><br />\nФайл сначала загружается на сервер, а потом копируется в папку upl и с ним работаем. По-другому небезопасно.</p>\n\n<p><br />\nДерево строится с N ветвями<br />\nлогика написана должна быть без привязки к конкретным ветвям, $mp3, $tv, ...</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Обработка дерева.<br />\nСобрать ветки:<br />\n1. Отсортировать массив с данными, так чтоб корневые ветви были первые.<br />\n2. Создать основной узел $goods = new C\\CompositeGoods(0,&quot;goods&quot;), через фабрику.<br />\n&nbsp;&nbsp; &nbsp;$goods = $factory-&gt;create(array(&#39;nodeId&#39;=&gt;0, &#39;nodeName&#39;=&gt;&#39;goods&#39;));<br />\n3. Написать класс итератор, который может перебирать дерево и находить узлы по id.</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Итератор.<br />\n1. Нужно отнаследоваться от CompositeGoods и написать класс RootCompositeGoods. Этот класс в себе должен содержать итератор.<br />\n2. Правильнее seek должен переводить указатель итератора на нужный элемент, а current() - возвращает его, в seek без рекурсии не обойтись.<br />\nа каким оператором обход будешь делать не важно foreach, for, ...</p>\n\n<p>Итераторы отдельно не создаются обычно, они предоставляются коллекциями.</p>\n\n<p>&nbsp;&nbsp; &nbsp;$goods = $factory-&gt;createRoot(array(&#39;nodeId&#39;=&gt;0, &#39;nodeName&#39;=&gt;&#39;goods&#39;));<br />\n&nbsp;&nbsp; &nbsp;foreach($dataArray as $data) {<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$iterator = $goods-&gt;getIterator();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; $iterator-&gt;seek($data[&#39;parentId&#39;]);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; $parent = $iterator-&gt;current();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; $item = $factory-&gt;create($data);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; $parent-&gt;addChild($item);<br />\n&nbsp;&nbsp; &nbsp;}</p>\n\n<p><br />\n1. Нужно отнаследоваться от CompositeGoods и написать класс RootCompositeGoods. Этот класс в себе должен содержать итератор.<br />\ncreateRoot должен содержаться в классе GoodsFactory. В классе GoodsFactory в методе createRoot обращаюсь к RootCompositeGoods,<br />\n&nbsp;return new C\\RootCompositeGoods.</p>\n');        DB::table('tests')->insert(['id' => 3, 'active' => 1, 'title' => '2. Общая схема (действий)', 'slug' => 'schema', 'image' => '6cn3CuifqYoDHlwUWwY91aic2YHvXCOy.png', 'content' => $content, 'created_at' => '2015-08-25 13:57:12', 'updated_at' => '2015-08-25 14:05:08']);            $content = str_replace(array('\r\n', '\n', '\r'), "\n" , '<p>Настраиваем отдельный домен modera_test.loc,&nbsp;<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;http://modera_test.loc&nbsp;<br />\nModeraTest(C:\\Server\\data\\htdocs\\ModeraTest), МоderaTest - папка проекта.<br />\nПуть - C:\\apache\\localhost\\www\\МоderaTest\\public и домен навести на public.&nbsp;<br />\nВсе классы должны лежать на уровень выше чем \\public.&nbsp;<br />\nВ public только точка входа, это для безопастности.<br />\nСоздаём папку аpp, и в .htaccess наводим все обращения.</p>\n\n<p>В файлах httpd.conf, hosts, .htaccess добавляем необходимые настройки:</p>\n\n<p>&nbsp;&nbsp; &nbsp;httpd.conf<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;VirtualHost 127.0.0.1:80&gt;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DocumentRoot &quot;C:\\Server\\data\\htdocs\\ModeraTest\\public&quot;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Домен по которому вы сможете обращаться к виртуальному хосту.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ServerName modera_test.loc<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Алиас (добавочное имя) домена.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ServerAlias www.modera_test.loc<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;/VirtualHost&gt;</p>\n\n<p>&nbsp;&nbsp; &nbsp;hosts<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;127.0.0.1&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;modera_test.loc&nbsp;&nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*После редактирования файла hosts для внесения изменений необходима перезагрузка.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;.htaccess&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AddDefaultCharset utf-8<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;IfModule mod_rewrite.c&gt;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;RewriteEngine On<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;RewriteCond %{REQUEST_FILENAME} !-f<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;RewriteRule ^(.*)$ app.php [QSA,L]<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;/IfModule&gt;</p>\n');        DB::table('tests')->insert(['id' => 4, 'active' => 1, 'title' => '3. Настройка точки доступа и домена', 'slug' => 'domen', 'image' => 's0quY2CNPGI336SZdsSj42erlkt6hP8X.png', 'content' => $content, 'created_at' => '2015-08-25 14:15:54', 'updated_at' => '2015-09-24 06:00:27']);            $content = str_replace(array('\r\n', '\n', '\r'), "\n" , '<p>Пространства имён PHP предоставляют возможность группировать логически связанные классы, интерфейсы, функции и константы.&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Папки и неймспейсы должны совпадать, сделаем так, чтобы было удобно их классы использовать в других проектах, только перенеся папки.&nbsp;&nbsp; &nbsp;</p>\n\n<p>Все классы должны лежать на уровень выше чем \\public.&nbsp;<br />\nВ public только точка входа, это для безопастности.</p>\n\n<p>На одном уровне с public и general создаём папку src - в ней все классы и код только для этого проекта.<br />\nВ ней создаём controller, view. model -структуры бд в общем, у нас её нет тут.</p>\n\n<p><br />\nРаспределение классов по папкам для неймспейсов:&nbsp;&nbsp; &nbsp;<br />\n&nbsp; src&nbsp;<br />\nFactory\\GoodsFactory<br />\nComposite\\CompositeGoods<br />\nIterator\\IteratorGoods<br />\nостальное - general</p>\n\n<p><br />\nsrc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;general</p>\n\n<p>Factory\\GoodsFactory&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File\\File<br />\nComposite\\CompositeGoods&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File\\TextFile<br />\nIterator\\IteratorGoods &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Parser\\TextParser</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\nFile, TextFile, Parser - многоразово можно использовать.<br />\nGoodsFactory, CompositeGoods, IteratorGoods - только в этом проекте.</p>\n');        DB::table('tests')->insert(['id' => 5, 'active' => 1, 'title' => '4. Определение неймспейсов', 'slug' => 'namespace', 'image' => 'EE1uB1cVIaJ6m0GfpX8arUvWOGy3zgxK.png', 'content' => $content, 'created_at' => '2015-08-25 14:30:04', 'updated_at' => '2015-09-24 06:08:32']);            $content = str_replace(array('\r\n', '\n', '\r'), "\n" , '<p>Применённые (использованные) шаблоны.</p>\n\n<p>Шаблон проектирования - это задача взятая из практики передовых программистов, решение которой проанализировано и обьяснено.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Мэтт Зандстра - PHP. Объекты, шаблоны и методики программирования - 2011.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\nПоскольку при постановке задания хотели увидеть High Performance решение, применено использование следующих шаблонов проектирования:<br />\n&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Composite (Компоновщик)<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Factory Method (Фабричный метод)<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Iterator (Итератор)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />\nComposite (Компоновщик). Обьединяет обьекты в древовидную структуру для представления иерархии от частного к целому.<br />\nКомпоновщик позволяет клиентам обращаться к отдельным обьектам и к группам обьектов одинаково. Основным назначением паттерна<br />\nявляется обеспечение единого интерфейса как к составному так и конечному обьекту, чтобы клиент не задумывался над тем, с каким обьектом он работает.&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;&lt;<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%BE%D0%B2%D1%89%D0%B8%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" target="_blank">ссылка на Википедию</a>&gt;&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n\n<p>Factory Method (Фабричный метод). Используется для определения и поддержания отношений между обьектами.<br />\nФабричные методы избавляют проектировщика от необходимости встраивать в код зависящие от приложения классы. &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;&lt;<a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" target="_blank">ссылка на Википедию</a>&gt;&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n\n<p>Iterator (Итератор). Обьект, позволяющий перебирать все элементы коллекции без учёта особенности её реализации.<br />\nIterator (Итератор). Представляет собой обьект, позволяющий получить последовательный доступ к элементам обьекта-агрегата без использования описания<br />\nкаждого из обьектов, входящих в состав агрегации. &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt;<a href="https://ru.wikipedia.org/wiki/%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" target="_blank">ссылка на Википедию</a>&gt;&gt; &nbsp; &nbsp;&nbsp;</p>\n');        DB::table('tests')->insert(['id' => 7, 'active' => 1, 'title' => '5. Применённые шаблоны', 'slug' => 'patterns', 'image' => 'dbMwsFT6UJbr8wmnlaSh1YAFzLYP9Ih7.png', 'content' => $content, 'created_at' => '2015-08-26 07:16:53', 'updated_at' => '2016-01-26 15:32:41']);            $content = str_replace(array('\r\n', '\n', '\r'), "\n" , '<p><a id="top" name="top"></a></p>\n\n<p>&nbsp;</p>\n\n<p><a href="#all">/***********************************************ОБЩИЕ РЕКОМЕНДАЦИИ.***********************************************************************************/</a><br />\n<a href="#File">/*************************************************class File{}******************************************************************************************************/</a><br />\n<a href="#TextFile">/*************************************************class TextFile**************************************************************************************************/</a><br />\n<a href="#TextParser">/*************************************************class TextParser***********************************************************************************************/</a><br />\n<a href="#CompositeGoods">/*************************************************class CompositeGoods***************************************************************************************/</a><br />\n<a href="#GoodsFactory">/*************************************************class GoodsFactory*******************************************************************************************/</a><br />\n<a href="#ФОРМА">/*************************************************ФОРМА********************************************************************************************************/</a><br />\n<a href="#IndexController">/*************************************************class IndexController(FileProcessController)***************************************************************/</a><br />\n<a href="#route.yml">/*************************************************конфиг-файл(route.yml)*************************************************************************************/</a><br />\n<a href="#Route">/*************************************************class Route****************************************************************************************************/</a><br />\n<a href="#Kernel">/*************************************************class Кernel{}**************************************************************************************************/</a><br />\n<a href="#Composer">/*************************************************COMPOSER**************************************************************************************************/</a><br />\n<a href="#SPL_AUTOLOAD">/*************************************************SPL_AUTOLOAD*********************************************************************************************/</a><br />\n<a href="#schema">/*************************************************СХЕМА действий********************************************************************************************/</a><br />\n<a href="#РЕФАКТОРИНГ">/*************************************************РЕФАКТОРИНГ(IndexController)***************************************************************************/</a><br />\n<a href="#Iterator">/******************************************************class Iterator*********************************************************************************************/</a><br />\n<a href="#RootCompositeGoods">/******************************************************class RootCompositeGoods****************************************************************************/</a></p>\n\n<p><br />\n&nbsp;</p>\n\n<p><a id="all" name="all"></a>/***********************************************ОБЩИЕ РЕКОМЕНДАЦИИ.***********************************************************************************/</p>\n\n<p>* в конструкции if всегда ставь { } &nbsp;даже если там одна строка.</p>\n\n<p>* отступ ставь табом(4 пробела).</p>\n\n<p>* при объявлении методов класса скобки ставь с новой строки, при if и тд как и ставил.<br />\n&nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;public function query($sqlQuery, $getType = &quot;assoc&quot;)&nbsp;<br />\n&nbsp;&nbsp; &nbsp;{<br />\n&nbsp;&nbsp; &nbsp; if($hfhf){<br />\n&nbsp;&nbsp; &nbsp; &nbsp;$a=$b;<br />\n&nbsp;&nbsp; &nbsp; }<br />\n&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;<br />\n* забудь про русский язык в коде, формат записи в лог [2013-07-18 00:08:02] INFO:****************************</p>\n\n<p>&nbsp;&nbsp; &nbsp;<br />\n1) Никогда не пиши описание класса и реализацию в одном файле. 1 класс = 1 файл. Файл называется так же как и класс.</p>\n\n<p>2) Зачем хранить содержимое файла в переменной $this -&gt;text = $text;? Тем более ты этого не используешь.</p>\n\n<p>3) Зачем ты слепил чтение одного файла с записью другого в одном классе, это франкинштейн. Нужен еще один класс файл который запишет данный.</p>\n\n<p>4) метод write может содержать дополнительные параметры, но они должны быть по умолчанию, типа:<br />\n&nbsp;&nbsp; &nbsp;public function write($content, $flags=FILE_APPEND)<br />\n&nbsp;&nbsp; &nbsp;<br />\nПерестраивай свой мозг на работу с объектами. Что такое public $str; и зачем? - really bad smells code.</p>\n\n<p>Я не написал явно, думал ты поймешь. В методы не нужно передавать путь к файлу. Путь к файлу передавал в конструкторе в моём примере,<br />\nи один экземпляр класса будет работать только с одним файлом, это понятно.&nbsp;</p>\n\n<p>Твой класс безсмысленен в рамках ООП. Класс файл должен быть обёрткой над файлом, и внутри кода ты с ним работаешь, как с файлом.<br />\nПеременные с названием my..., тоже bad smells. Переменная(название) должна нести смысл.</p>\n\n<p>Если представить игру Герои, &nbsp;у нее есть класс Hero. Ты ведь для каждого героя игры создашь отдельный экземпляр класса Hero. Или будет один и ты создашь метод передвижения по карте<br />\n&nbsp;&nbsp; &nbsp;public function move($heroName, $heroLevel, $heroExp, ..., $pointX, $pointY)</p>\n\n<p>/***!!!код должен читаться!!!***//<br />\n&nbsp;&nbsp; &nbsp;колличество методов класса должно быть не больше 13<br />\n&nbsp;&nbsp; &nbsp;вложенность if, for не больше 2<br />\n&nbsp;&nbsp; &nbsp;колличество строк меньше 100<br />\n//******************************//</p>\n\n<p>Форматирование кода:<br />\nСтиль кодирования- http://framework.zend.com/manual/1.12/ru/coding-standard.coding-style.html&nbsp;</p>\n\n<p>Для переменных камелкейс стиль - слияние слов, начальное слово с маленькой, второе слово с большой.</p>\n\n<p>&nbsp;- с большой буквы только название Классов, Интерфейсы<br />\n&nbsp;&nbsp; &nbsp;//textParserInterFace нужно TextParserInterFace<br />\n&nbsp;&nbsp; &nbsp;//InterFace - Interface</p>\n\n<p>NAMESPACE - использовать вместо require/include.</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/*Пример классов.<br />\nСмотри на классы как на чёрные ящики, у которых есть функции. Пример Стиральная машинка. Ты знаешь что там у нее внутри, ты используешь ее публичные фукции стирать, выкручивать.<br />\nА когда ты захочешь поменять машинку на новую, все её старые функции останутся стирать, выкручивать, но могут добавится новые сушить, гладить.<br />\nТак вот ты как потребитель работаешь с интерфейсом стиральная машина, а не с конкретным объектом, и не заморачиваешься о ее внутренностях<br />\nтак и твой код должен работать через интерфейсы, тогда будет легко делать апгрейд стиралок.</p>\n\n<p>Конкретика: обычно объект создает фабрика, билдер, ... порождающие паттерны, они хорошо знают свои объекты (Заводы по производству стиралок)&nbsp;<br />\nи так метод getPathToFile() как setPathToFile() - интерфейсу не нужны.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*/</p>\n\n<p>Фактори метод работает с одним обьектом - веткой(если б с 2мя и более(ветка и лист(окна и двери, либо схожие обьекты) например), то это абстрактная фабрика),&nbsp;<br />\nКомпоновщик(по айди выстраивает ветки(children,дети)).<br />\nИтератор проходит по этой структуре и возвращает необходимое значение.<br />\nMVC +(пользовательский интерфейс).</p>\n\n<p>Компоновщик - и есть дерево, он хранит данные.<br />\nИтератор - &quot;сервис&quot; умеет работать с итератором, искать, перебирать, ...<br />\nM - модель (твои объекты, File, Composite, ...).<br />\nV - вьюшка, отвечает за отображение результата работы.<br />\nC - контроллер, выполняет действия связанные с получением результата.</p>\n\n<p>&nbsp;Абстрагируй сложные части:<br />\n&nbsp;&nbsp; &nbsp;- Парсер - преобразует данные.<br />\n&nbsp;&nbsp; &nbsp;- Фабрика создает ноды, по одной.<br />\n&nbsp;&nbsp; &nbsp;- Контроллер содержит логику выполнения программы.<br />\n&nbsp;&nbsp; &nbsp;- Итератор нужен для перебора коллекций(композиции в твоем случае).</p>\n\n<p>- Фабрика создает ноды(Composite), по одной и все. Создала один объект о коллекциях она понятия не имеет. Так что да в контроллере, или еще каком то помошнике, но не в фабрике.<br />\nАвтомобили создаются в одном месте? Даже двигатели создаются из частей которые производятся в разных местах, а собираются в одном месте.<br />\nНода - это чаcть авто, композиция - авто. Аккумуляторный завод знает что-то про авто? Или шинный завод. Тогда почему ты хочешь собирать авто на шинном заводе?<br />\nАвтомобиль собирают в крупноузловом цеху - это контроллер.<br />\nДвигатель собирают в двигательном цеху и в рамках проекта это будет вспомогательный сервис, для разгрузки контроллера.&nbsp;&nbsp; &nbsp;</p>\n\n<p><br />\nВ Composite, &nbsp;parentId - мы не используем, может тоже добавить как имя и айди?<br />\n&nbsp;&nbsp; &nbsp;Связь, только от старшего к младшему, узел не знает кто его включает в себя, в этом вся сила правильного проектирования.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*******************************************************<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;узел не знает кто его включает в себя, в этом вся сила правильного проектирования<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;элемент массива знает в каком он массиве находится?&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*******************************************************<br />\nКомпозит не выводит данные на экран, он может только вернуть, в нужном виде. Никакого принт и эхо в классах!!!<br />\nКомпозит не выводит данные на экран - никаким способом. Это хранилище.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p><br />\nview - ничего не знает о композиции и других структурах</p>\n\n<p>&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;header(&#39;Content-Type: text/html; charset=utf-8&#39;); -этого тоже не должно быть в классе<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.htaccess - нормальное место, или в контроллере, но не в классе</p>\n\n<p>&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;error_reporting(E_ALL);<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!!! error_reporting(E_ALL&amp;~E_NOTICE);<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Нотайсы нужны, при разработке обязательно. На продакшин сервере отключать для безопасности - продакшин это проект в мире на который ходят люди.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;php динамический язык и многое не считает ошибкой, а говорит что это возможно ошибка.<br />\n&nbsp;&nbsp; &nbsp;error_reporting(E_ALL);</p>\n\n<p>&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;class TextFile<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public function __construct($path){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this -&gt;pathToFile = $path;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this -&gt;pathToFile отсутствует у этого класса, он есть у родителя и причем приватный,<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;PHP не считает это ошибкой, а создаёт динамически свойство класса pathToFile, это неправильно -надо исправить.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;нужен геттер? либо модификатор доступа не приват, какой поставишь?<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- protected</p>\n\n<p>&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;NAMESPACE<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Пространства имен PHP предоставляют возможность группировать логически связанные классы, интерфейсы, функции и константы.&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Папки и неймспейсы должны совпадать, сделай так, чтобы тебе было удобно их классы использовать в других проектах, только перенеся папки.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Parser, File, TextFile - многоразово можно использовать.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Factory, Composite - только в этом проекте.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;Все классы должны лежать на уровень выше чем \\public. В паблике только точка входа, это для безопастности.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp;&nbsp; &nbsp;<br />\nwrite.txt - этого файла по идее не должно быть, так как ты его загружаешь.</p>\n\n<p><br />\nРасположение файла формы в src.</p>\n\n<p><br />\n/************************ФОРМА*************************************************************/<br />\nСмотри, как я вижу. Тебе нужно сделать визуальную часть. Формочка которая запрашивает файл,<br />\nзагружает его, парсит, выводит на экран результат.<br />\n/************************ФОРМА*************************************************************/</p>\n\n<p><br />\n//**********************(абс и относит ссылки)************************************//<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;<br />\n&nbsp;&nbsp; &nbsp;или&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;form action=&quot;http://modera_test.loc/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/- корень, УКАЗЫВАЕМ ПЕРЕД АДРЕСОМ.<br />\n//**********************(абс и относит ссылки)************************************//&nbsp;</p>\n\n<p>Ты должен понимать, что интерфейс описывает те методы, которые нужны всегда,<br />\nесли ты будешь делать новый проект, то этот интерфейс тебе не подойдет,<br />\nтак как там могут быть др. экшины. Например default, List, Catalog.</p>\n\n<p><br />\nЭто весь route.yml:<br />\n&nbsp;index: &nbsp;[/, IndexController.indexAction]<br />\n&nbsp;upload: [/upload, IndexController.uploadAction]<br />\n&nbsp;list: &nbsp; [/list, IndexController.listAction]<br />\nв примерах чаще config.yml-<br />\n&nbsp;&nbsp; &nbsp;config.yml - это общий конфиг чаще всего, для роутинга используется свой, так и понятнее.<br />\n&nbsp;&nbsp; &nbsp;</p>\n\n<p>Сделай еще одну папку на одном уровне с src и назови её app, в аpp 2 папки с соотвующими классами.&nbsp;&nbsp; &nbsp;</p>\n\n<p><br />\nЗаменяем хардкод, что уже есть в public/app.php /* Пути по-умолчанию для поиска файлов */<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/*хардкод*/<br />\n/*Данный антипаттерн подразумевает жесткое &laquo;вшивание&raquo; в программный код различных данных,<br />\n&nbsp;касающихся окружения программы. Например, это могут быть: путь к файлу конфигурации,&nbsp;<br />\n&nbsp;имя почтового сервера, имя bluetooth-устройства, имя процесса, с которым взаимодействует программа,<br />\n&nbsp;и так далее. Этот список можно продолжать долго. Одни словом &mdash; &laquo;захардкодить&raquo; означает прописать&nbsp;<br />\n&nbsp;значение каких-либо данных непосредственно в коде, вместо того, чтобы передавать их в качестве параметра.<br />\nХардкодинг несет в себе скрытую опасность. На компьютере разработчика программа будет прекрасно работать,<br />\n&nbsp;но стоит ее только перенести на новую систему, как программа потеряет свою работоспособность.<br />\n&nbsp;Хардкодинг невозможно выявить на машине разработчика без досконального изучения кода, и поэтому,&nbsp;<br />\n&nbsp;если программист захардкодил какие-то значения (и, как правило, забыл, где он это сделал) ,&nbsp;<br />\n&nbsp;то такая программа будет иметь совершенно непредсказуемое поведение,<br />\n&nbsp;а сложность выявления и локализации ошибок станет невероятно высокой. */<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/*хардкод*/<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\nИнклуды в файлах кроме app.php или классов autoloader.php - хардкод, инклуды и реквайреды.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\ndefine - вообще не должно быть.</p>\n\n<p>Почему мы обошлись без model.&nbsp;<br />\n&nbsp;&nbsp; &nbsp;Model -структуры бд в общем. У тебя её нет тут.</p>\n\n<p>&nbsp;&nbsp; &nbsp;<br />\n1. ты в браузере вбиваешь адрес modera.loc/<br />\n&nbsp;&nbsp; &nbsp;2. выполняется скрипт файла app.php<br />\n&nbsp;&nbsp; &nbsp;2.1 Инициализация кернел - в котором читается конфиг роутинга<br />\n&nbsp;&nbsp; &nbsp;2.2 запускаем просес с параметрами из конфига роутинга&nbsp;<br />\n&nbsp;&nbsp; &nbsp;[ &nbsp;[&quot;controller&quot;]=&gt; &nbsp;&quot;src\\Controller\\IndexController&quot;, &nbsp;[&quot;action&quot;]=&gt;&quot;indexAction&quot;]]<br />\n&nbsp;&nbsp; &nbsp;в котором создаем объект контроллера и выполняем его метод indexAction<br />\n&nbsp;&nbsp; &nbsp;Метод контроллера выполняет действия и как результат работы возвращает массив данных, который мы передадим в рендер.</p>\n\n<p><br />\nУ тебя есть страница отображения каталога товаров абстрактный пример:<br />\n&nbsp;&nbsp; &nbsp;Page 1 (some text ... )<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;|id|name|price|<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(some text)<br />\n&nbsp;&nbsp; &nbsp;Для отображения данной страницы. Контроллер выбирает данные из БД/файла/или др. источника и возвращает массив вида:<br />\n&nbsp;&nbsp; &nbsp;[<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[&#39;id&#39; =&gt;1, &#39;name&#39;=&gt;&#39;HDD&#39;, &#39;price&#39;=&gt;250],<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[&#39;id&#39; =&gt;2, &#39;name&#39;=&gt;&#39;SSD&#39;, &#39;price&#39;=&gt;550],<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;...<br />\n&nbsp;&nbsp; &nbsp;]&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;<br />\n/**************/<br />\n&nbsp;&nbsp; &nbsp;Если не нужны данные, то контроллер пустой и возвращает ничего.<br />\n/**************/&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>\n\n<p><br />\nВ кернеле есть &nbsp;&nbsp; &nbsp;$route = $this-&gt;route = new Route($routeConfig); есть явно лишняя переменная $route и нет объявленного свойства класса $this-&gt;route.<br />\nв кернеле объяви свойство класса route и&nbsp;<br />\n&nbsp;&nbsp; &nbsp;$this-&gt;route = new Route($routeConfig); достаточно.</p>\n\n<p>public function getRoute(){//возвращает объект Route &nbsp;<br />\n&nbsp; return $route = $this-&gt;route; &nbsp;<br />\n&nbsp; &nbsp; }<br />\n&nbsp;&nbsp; &nbsp;то же,тут тоже индуский код, зачем тебе $route?&nbsp;<br />\n&nbsp;&nbsp; &nbsp; - return $this-&gt;route; достаточно.<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;<br />\nФайл сначала загружается на сервер, а потом копируется в папку upl и с ним работаем. По другому небезопастно.</p>\n\n<p>Дерево строится с N ветвями. Логика написана должна быть без привязки к конкретным ветвям, $mp3, $tv, ...</p>\n\n<p><br />\nСобрать ветки:<br />\n1. Отсортировать массив с данными, так чтоб корневые ветви были первые.<br />\n2. Создать основной узел $goods = new C\\CompositeGoods(0,&quot;goods&quot;). Но не так как ты это сделал, а через фабрику.<br />\n&nbsp;&nbsp; &nbsp;$goods = $factory-&gt;create(array(&#39;nodeId&#39;=&gt;0, &#39;nodeName&#39;=&gt;&#39;goods&#39;));<br />\n3. Написать класс итератор, который может перебирать дерево и находить узлы по id.</p>\n\n<p><br />\n1. Нужно отнаследоваться от CompositeGoods и написать класс RootCompositeGoods. Этот класс в себе должен содержать итератор.<br />\n&nbsp;&nbsp; &nbsp;createRoot должен содержаться в классе GoodsFactory, в классе GoodsFactory в методе createRoot обращаюсь к RootCompositeGoods,<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return new C\\RootCompositeGoods<br />\n2. Правильнее seek должен переводить указатель итератора на нужный элемент, а current() - возвращает его. В seek без рекурсии не обойтись,&nbsp;<br />\nа каким оператором обход будешь делать не важно foreach, for, ...</p>\n\n<p>Итераторы отдельно не создаются обычно, они предоставляются коллекциями</p>\n\n<p>$goods = $factory-&gt;createRoot(array(&#39;nodeId&#39;=&gt;0, &#39;nodeName&#39;=&gt;&#39;goods&#39;));<br />\nforeach($dataArray as $data) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$iterator = $goods-&gt;getIterator();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$iterator-&gt;seek($data[&#39;parentId&#39;]);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$parent = $iterator-&gt;current();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$item = $factory-&gt;create($data);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$parent-&gt;addChild($item);<br />\n}</p>\n\n<p><br />\n/**********************************************************************************/<br />\npublic function find(array $dataArray, $position) - не публичный.<br />\narray $dataArray - массив объектов должен быть, а не многомерный массив.<br />\nпонятно, ты просто кидаешь туда не композицию(Composite), а массив.<br />\n/**********************************************************************************/&nbsp;</p>\n\n<p><br />\nПолучилось собрать дерево -(добавил в find (int) в условие).<br />\nСмести все индексы на 1, чтоб рут стал 1, а остальные после него,(для этого нужно сместить и parentId сместить на 1)- пологаю дерево не должно собраться.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Всё работает. Пробовал 2 варианта.<br />\nНасильное приведение типов, что-то скрыло, ты же нигде не использовал === для сравнения.(?ВОПРОС).<br />\n/***********************************************ОБЩИЕ РЕКОМЕНДАЦИИ.***********************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="File" name="File"></a><br />\n/*************************************************class File{}****************************************************************************************/<br />\n&nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;public function getFile(){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return $this -&gt; pathToFile;<br />\n&nbsp;&nbsp; &nbsp;} &nbsp;<br />\nЭто геттер, берёт приват значение св-ва.<br />\n&nbsp;&nbsp; &nbsp;bad smells, почему он так называется? Геттер должен иметь название свойства getPathToFile().<br />\n&nbsp;&nbsp; &nbsp;Вернемся к твоему public function getFile(){ в названии смысл должен быть, какой тут? Код должен читаться, есть объект File и у него метод getFile()<br />\n&nbsp;&nbsp; &nbsp;по смыслу он должен вернуть объект File, но никак не путь к нему.&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp;&nbsp; &nbsp;function getContent(){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return file_get_contents($this-&gt;getFile()); &nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;} &nbsp;<br />\n&nbsp;<br />\nСсмысл нужно вкладывать абстрактный, работа с файлом. Мало ли в каком проекте он понадобится.&nbsp;<br />\nПросто помошник для записи и чтения.<br />\nЗапись может быть с перезаписью и дозаписью.<br />\nЧтение может быть всего или построчно например. Итого - 4 способа. Это можно впихнуть в 2 метода, но читабельней и аккуратнее будет 4 на мой собственный взгляд.<br />\nэто раз<br />\nдва,<br />\n&nbsp;файла может не быть или доступа к нему, нужно это обработать(проверка на существование файла).<br />\nтри&nbsp;<br />\n- раз ты ООП программер, то ты должен сделать интерфейс с 4 методами и от него отнаследовать File<br />\nне отнаследовать а отимплиментить, сорри.</p>\n\n<p>Я имел ввиду, что вспомогательные методы класса, которые нужны только этому классу должны быть протектед или приват, например проверки разные,<br />\npublic -должны быть только те, что ты используешь вне класса.</p>\n\n<p>read, write, clear, readLine(readRow), может getCountLines -можно построчно читать и обрабатывать, есть варианты, я ж говорю 101 способ.</p>\n\n<p><br />\nТы можешь писать парсер для всего содержимого класса, тогда у тебя read, write, clear публик функции и все, а можешь писать парсер только для строки,<br />\n&nbsp;тогда у тебя будет еще getCountLines и &nbsp;readLine.</p>\n\n<p><br />\nПример классов.<br />\nСмотри на классы как на черные ящики, у которых есть функции. Пример Стиральная машинка. Ты знаешь что там у нее внутри, ты используешь ее публичные фукции стирать, выкручивать.<br />\nА когда ты захочешь поменять машинку на новую, все её старые функции останутся стирать, выкручивать, но могут добавится новые сушить, гладить.<br />\nТак вот ты как потребитель работаешь с интерфейсом стиральная машина, а не с конкретным объектом, и не заморачиваешься о ее внутренностях,<br />\nтак и твой код должен работать через интерфейсы, тогда будет легко делать апгрейд стиралок.</p>\n\n<p>Конкретика: обычно объект создает фабрика, билдер, ... порождающие паттерны, они хорошо знают свои объекты (Заводы по производству стиралок).&nbsp;<br />\nи так метод getPathToFile() как setPathToFile() - интерфейсу не нужны.</p>\n\n<p>Считаю интерфейс должен быть из :<br />\n&nbsp;public function read();&nbsp;<br />\n&nbsp;public function write($content);<br />\n&nbsp;public function clear();<br />\nили<br />\n&nbsp;public function getCountent();<br />\n&nbsp;public function setCountent($content);<br />\n&nbsp;public function removeCountent();<br />\nПро значения по-умолчанию public function rewrite($str, $flags = FILE_WRITE); Это был частный случай той логики что ты показывал.<br />\n$flags = FILE_WRITE, концепция работы с файлом ограничивается тремя функциями, как и твоя работа со стиралкой.</p>\n\n<p>Можно для включения методов с Line в интерфейс:<br />\n1. Отнаследовать от FileInterface новый интерфейс TextFileInterface и в нем объявить методы с Line. &nbsp;&nbsp;</p>\n\n<p>&nbsp;&nbsp; &nbsp;/******************корректировка setContent и addLine****************************/<br />\n&nbsp;&nbsp; &nbsp;Нельзя использовать die($e-&gt;getMessage()); внутри классов.<br />\n&nbsp;&nbsp; &nbsp;Твой класс делает работу с файлом, и если и перехватывает какие события, то лишь с целью запустить альтернативную логику или дополнить эксцепшин.<br />\n&nbsp;&nbsp; &nbsp;Обрабатываются эксцепшины в контроллере:<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;try{ &nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; if(!file_put_contents($source,$content,$flags))<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;throw new Exception(&quot;The file_put_contents NOT done. content = $content&quot;); &nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}catch(Exception $e){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;die($e-&gt;getMessage());<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- жесткая жесть<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;блок try /catch - выполняет код и ловит исключения, в твоем коде, кто кидает исключения?<br />\n&nbsp;&nbsp; &nbsp;file_put_contents &nbsp;- не кидает, следовательно:<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(false === file_put_contents($source,$content,$flags)) {<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new Exception(&quot;The file_put_contents NOT done. content = $content&quot;);<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- даже больше скажу, это все тело функции, больше ничего не нужно.</p>\n\n<p>&nbsp;&nbsp; &nbsp;Внимание!!! -Эта функция может возвращать как boolean FALSE, так и не-boolean значение, которое приводится к FALSE.&nbsp;<br />\n&nbsp;&nbsp; &nbsp;За более подробной информацией обратитесь к разделу Булев тип. Используйте оператор === для проверки значения, возвращаемого этой функцией.<br />\n&nbsp;&nbsp; &nbsp;- более точно, &nbsp;думал (!file_put_contents ) &nbsp;достаточно<br />\n&nbsp;&nbsp; &nbsp;$flags - вместо этого FILE_APPEND&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;а для сет(а), третий пар-р не указываем?<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- правильно<br />\n&nbsp;&nbsp; &nbsp;в аddLine то же тело только разница в пар-рах?<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(false === file_put_contents($source, $content, FILE_APPEND)) {<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new Exception(&quot;The file_put_contents NOT done. content = $content&quot;);<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}это и есть &nbsp;аddLine, а не наоборот. без параметра будет сет.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Описание ошибки - Can&#39;t add line to file.Can&#39;t set content to file - для сета.</p>\n\n<p>&nbsp;&nbsp; &nbsp;Я говорил о проверке на существование и возможность писать, читать и эти проверки нужно делать при создании объекта.<br />\n&nbsp;&nbsp; &nbsp;<br />\nif(!file_exists - повторяется, кроме того, что не нужно там, file_exists - можно использовать при чтении из файла или при дополнительной обработке&nbsp;<br />\nнеудачного действия, но это усложнение, тебе не нужно.<br />\n/*********корректировка setContent и addLine*****************************************/</p>\n\n<p>/******************************************************class File****************************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="TextFile" name="TextFile"></a><br />\n/******************************************************class TextFile************************************************************************************/</p>\n\n<p>class TextFile<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public function __construct($path){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this -&gt;pathToFile = $path;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this -&gt;pathToFile отсутствует у этого класса, он есть у родителя и причем приватный,<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;PHP не считает это ошибкой, а создет динамически свойство класса pathToFile, это неправильно -надо исправить.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Нужен геттер? либо модификатор доступа не приват, какой поставишь?<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- protected.<br />\n/******************************************************class TextFile************************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="TextParser" name="TextParser"></a></p>\n\n<p>/******************************************************class TextParser**********************************************************************************/<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;Структура должна быть такая, чтобы было удобно создавать Items для Composite паттерна,<br />\n&nbsp;&nbsp; &nbsp;думаю что:<br />\n&nbsp;&nbsp; &nbsp;array (<br />\n&nbsp;&nbsp; &nbsp; &nbsp;array(&quot;id&quot;=&gt;2, &quot;parrentId&quot;=&gt;&quot;1&quot;, &quot;name&quot;=&gt;&quot;Электроника&quot;),<br />\n&nbsp;&nbsp; &nbsp; &nbsp;array(...),<br />\n&nbsp;&nbsp; &nbsp; &nbsp;...<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;);<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;setContent() ничего не дозаписывает, он устанавливает новое наполнения, хочешь дописывать другое должно быть название addLine() например,<br />\n&nbsp;&nbsp; &nbsp;у тебя есть окно и ты говоришь рабочему установи мне новое окно, добавив условие доставив к уже существующему.<br />\n&nbsp;&nbsp; &nbsp;он тебе может конечно 2 окна установить рядом в квартире, это нормально?<br />\n&nbsp;&nbsp; &nbsp;Устанавливает новое значение взамен старого, как рабочий меняет новое окно на старое, все set методы так работают -только заменяют.<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;$Array4parse - режет глаз, предложил бы lineData но то мелочи.<br />\n/******************************************************class TextParser**********************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="CompositeGoods" name="CompositeGoods"></a></p>\n\n<p>/******************************************************class CompositeGoods******************************************************************************/</p>\n\n<p>Input data:<br />\n1|0|Electronics<br />\n2|0|Video<br />\n3|0|Photo<br />\n4|1|MP3 player<br />\n5|1|TV<br />\n6|4|iPod<br />\n7|6|Shuffle<br />\n8|3|SLR<br />\n9|8|DSLR<br />\n10|9|Nikon<br />\n11|9|Canon<br />\n12|11|20D</p>\n\n<p>Эти данные нужно превратить в структуру, первая колонка это id, вторая это partner_id, третья это name<br />\nElectronics, Video, Photo - ветки, остальное листья.</p>\n\n<p>Фабрика, или билдер создает ветку если parrent_id = 0 и лист если parrent_id != 0<br />\n- не, там есть еще уровень, я не глянул.</p>\n\n<p>Лист, только если нет потомка(у когото parent_id &nbsp;этого элемента)<br />\n&nbsp;&nbsp; &nbsp;7|6|Shuffle<br />\n&nbsp;&nbsp; &nbsp;12|11|20D<br />\n&nbsp;&nbsp; &nbsp;листья<br />\n&nbsp;&nbsp; &nbsp;5|1|TV<br />\nНо можно упростить, и делать все ветками, как я уже тебе когда-то говорил.</p>\n\n<p><br />\nветка=Composite=назови как считаешь нужным<br />\n&nbsp;&nbsp; &nbsp;https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%BE%D0%B2%D1%89%D0%B8%D0%BA_%28%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29<br />\nВетка это тоже самое что и Composite в описании патерна Компоновщик.<br />\nВсе объекты веток, создаются фабрикой, или похожим паттерном билдер.</p>\n\n<p>interface Goods<br />\nclass Leaf<br />\nНе правильно - абстракция должна быть абстрактной, а реализация конкретной.если поменять имена, будет правильнее.<br />\n&nbsp;&nbsp; &nbsp;interface Leaf&nbsp;<br />\n&nbsp;&nbsp; &nbsp;class Goods<br />\nВ interface Branch нужно еще методы заложить, addChild(Branch $branch) и getChildren().&nbsp;&nbsp; &nbsp;</p>\n\n<p><br />\n- Composite - структура(коллекция) элементов(данных, нод) в виде дерева.<br />\n&nbsp;&nbsp; &nbsp;Компоновщик (англ. Composite pattern) &mdash; структурный шаблон проектирования, относится к структурным паттернам, объединяет объекты в древовидную структуру для представления иерархии.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(wikipedia.org)</p>\n\n<p>тебе нужно&nbsp;<br />\nInput data:<br />\n1|0|Electronics<br />\n2|0|Video<br />\n3|0|Photo<br />\n4|1|MP3 player<br />\n5|1|TV<br />\n6|4|iPod<br />\n7|6|Shuffle<br />\n8|3|SLR<br />\n9|8|DSLR<br />\n10|9|Nikon<br />\n11|9|Canon<br />\n12|11|20D<br />\nпредставить в виде иерархии: &nbsp;<br />\nElectronics<br />\n-MP3 player<br />\n--iPod<br />\n---Shuffle<br />\n-TV<br />\nVideo<br />\nPhoto<br />\n-SLR<br />\n--DSLR<br />\n---Nikon<br />\n---Canon<br />\n----20D</p>\n\n<p><br />\npublic function getChildren(){ &nbsp;-возвращает подветки, узлы -потомки.<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;- чилдренов нельзя так хранить $this-&gt;children[$node-&gt;name] = $node; &nbsp;-имена НЕ уникальное поле.<br />\n&nbsp;&nbsp; &nbsp;$this-&gt;children[] = $node;</p>\n\n<p><br />\n&nbsp;- у ноды еще есть id ,параметр класса, как name.<br />\n&nbsp;&nbsp; &nbsp;private $id;</p>\n\n<p>&nbsp;- это в конструктор -<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public function __construct($name){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this-&gt;name = $name;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this-&gt;id = $id;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\nДля name - есть getName(), для id - getId() , в конструктор добавляем id. &nbsp;$this-&gt;id = $id;</p>\n\n<p>Есть ещё вопрос по Composite, &nbsp;parentId - мы не используем, может тоже добавить как имя и айди?<br />\n&nbsp;&nbsp; &nbsp;Связь, только от старшего к младшему, узел не знает кто его включает в себя, в этом вся сила правильного проектирования.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;*******************************************************<br />\n&nbsp;&nbsp; &nbsp;узел не знает кто его включает в себя, в этом вся сила правильного проектирования<br />\n&nbsp;&nbsp; &nbsp;элемент массива знает в каком он массиве находится?&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;*******************************************************</p>\n\n<p>//**********************рекурсия display()************************//&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;display должен выглядеть примерно&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;function display(...){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;foreach($this-&gt;children as $child) {<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$child-&gt;display(...);<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;$child - это такая же нода как и родительская и у нее есть метод дисплей.<br />\n//**********************рекурсия display()************************//&nbsp;&nbsp; &nbsp;</p>\n\n<p>//******************getDataToPrint()=display()***********//<br />\nКомпозит не выводит данные на экран, он может только вернуть, в нужном виде. Никакого принт и эхо в классах!!!<br />\nКомпозит не выводит данные на экран - никаким способом. Это хранилище.</p>\n\n<p>&nbsp;&nbsp; &nbsp;<br />\naddChild($node);//NodeInterface $node Для чего в примере компоновщика указывается &quot;тип&quot; в параметрах?<br />\n&nbsp;&nbsp; &nbsp;Когда ты станешь пользоваться хорошими IDE ты поймешь, там для удобства.А вообще для того, чтоб в метод не передавалось непонятно что, интерпретатор ругнётся,<br />\n&nbsp;&nbsp; &nbsp;для порядка и стабильности системы, дополнительное системное ограничение, избавляет от проверки внутри метода на принадлежность к интерфейсу.</p>\n\n<p><br />\ngetDataToPrint (), лучше НЕ добавлять в интерфейс? -как не обязательную функцию.<br />\n&nbsp;&nbsp; &nbsp;можно и добавить, довольно нормальное название и может понадобится во многих случаях.</p>\n\n<p>&nbsp;&nbsp; &nbsp;view - ничего не знает о композиции и других структурах.</p>\n\n<p>//******************getDataToPrint()=display()***********//</p>\n\n<p>/******************************************************class CompositeGoods**************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="GoodsFactory" name="GoodsFactory"></a></p>\n\n<p>/******************************************************class GoodsFactory****************************************************************************/<br />\nФактори создает элементы Cоmposite. Cоmposite - не имеет никакого понятия о фабрике, никаких переплетений.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*********************************************************************************&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$factory = $this-&gt;getFactory(); // метод в контроллере, там где твоя логика будет<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$node = $factory-&gt;create($params);//$params - это данные из файла, строки,<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;а потом $node компонуешь в композицию<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$node-&gt;addChild($node1);<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;а то сам себя добавить<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;в итоге $node - и будет твоей композицией<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*********************************************************************************<br />\n- Фабрика создает ноды(Composite), по одной и всё. Создала один объект, о коллекциях она понятия не имеет. Так что да в контроллере, или еще каком-то помошнике, но не в фабрике.<br />\nАвтомобили создаются в одном месте? Даже двигатели создаются из частей которые производятся в разных местах, а собираются в одном месте.<br />\nНода - это чаcть авто, композиция - авто. Аккумуляторный завод знает что-то про авто? Или шинный завод. Тогда почему ты хочешь собирать авто на шинном заводе?<br />\nАвтомобиль собирают в крупноузловом цеху - это контроллер.<br />\nДвигатель собирают в двигательном цеху и в рамках проекта это будет вспомогательный сервис, для разгрузки контроллера.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\nСейчас ты можешь собрать всё авто в одном цеху, чтоб не путаться.&nbsp;&nbsp; &nbsp;<br />\n/******************************************************class GoodsFactory****************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="ФОРМА" name="ФОРМА"></a></p>\n\n<p>/************************ФОРМА*************************************************************/<br />\nСмотри, как я вижу. Тебе нужно сделать визуальную часть. Формочка которая запрашивает файл,<br />\nзагружает его, парсит, выводит на экран результат.<br />\nСоздай класс View с методом indexRender(array $params) передавай в него результат работы Controller-&gt;indexAction()<br />\n/************************ФОРМА*************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="IndexController" name="IndexController"></a></p>\n\n<p>/******************************************************class IndexController(FileProcessController)****************************************************************************/<br />\nFileProcessController<br />\nкак минимум 3 метода FileProcessController</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; index - по -умолчанию.<br />\nView/FileProcess/index.php - отображает результат метода index в контроллере &nbsp;FileProcessController.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; upload - для загрузки файла.<br />\nView/FileProcess/upload.php<br />\nupload - для загрузки файла, upload - обработка post запроса,<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; list - отображение результата.<br />\nView/FileProcess/list.php<br />\nИнформация о файле - колличество строк, размер.</p>\n\n<p>upload - обработка запроса загрузки файла.<br />\nindex - отображение формы.</p>\n\n<p>View/FileProcess/upload.php - это не обработчик, по этому пути может лежать только вьюшка, html страника.<br />\nУ тебя 1 контроллер. У контроллера несколько методов.</p>\n\n<p>index.php,upload.php, list.php - это вьюшки.</p>\n\n<p>Во вьюшке отображать результат работы соответствующего метода контроллера.<br />\nДля каждой вьюшки по методу:<br />\n&nbsp;&nbsp; &nbsp;modera_test.loc/index<br />\n&nbsp;&nbsp; &nbsp;modera_test.loc/upload<br />\n&nbsp;&nbsp; &nbsp;modera_test.loc/list</p>\n\n<p>modera_test.loc/index &nbsp; | &nbsp;modera_test.loc/upload &nbsp; &nbsp;| &nbsp;modera_test.loc/list<br />\nindexAction() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;uploadAction() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;listAction()<br />\nindex.php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;upload.php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;list.php</p>\n\n<p>action в форме указывает на обработчик запроса, все запросы обрабатывают контроллеры. Рядом с вьюшками - только вьюшки.<br />\n&nbsp;&nbsp; &nbsp;&lt;form action=&quot;modera_test.loc/upload&quot; method=&quot;post&quot;&gt;...&lt;/form&gt;<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;modera_test.loc/index &nbsp; &nbsp; &nbsp;- indexAction()<br />\n&nbsp;&nbsp; &nbsp;modera_test.loc/upload &nbsp; &nbsp; - uploadAction()<br />\n&nbsp;&nbsp; &nbsp;modera_test.loc/list &nbsp; &nbsp; &nbsp; - listAction()</p>\n\n<p>indexAction(), uploadAction(), listAction() - методы контроллера.</p>\n\n<p>Обращаешься по адресу modera_test.loc/index выполняется метод контроллера indexAction(), отображается форма загрузки файла,</p>\n\n<p>&nbsp;&nbsp; &nbsp;&lt;form action=&quot;modera_test.loc/upload&quot; method=&quot;post&quot;&gt;<br />\n&nbsp;&nbsp; &nbsp;&lt;input type=&quot;submit&quot; value&quot;Загрузить&quot;&gt;<br />\n&nbsp;&nbsp; &nbsp;&lt;/form&gt;<br />\nнажав на загрузить отправляются данные на modera_test.loc/upload выполняется метод uploadAction() и отображается &nbsp;upload.php</p>\n\n<p>Чтобы отобразить upload.php нужно выполнить метод контроллера uploadAction(),<br />\nметод контроллера uploadAction() выполняется после нажатия на кнопку &quot;Загрузить&quot;(файл), на вьюшке index.php</p>\n\n<p>//*************************uploadAction, upload*********************************************//<br />\n1) в контроллере только логика.<br />\n2) все что касается загрузки в upload.<br />\n&nbsp;&nbsp; &nbsp;Из контроллера во вьюшку ты передаешь данные типа array(&#39;fileName&#39;=&gt; $uploadfile, &#39;success&#39;=&gt;true, ...), во вьюшке их анализируй и выводи теги сколько хочешь.<br />\nв uploadAction, мы заполняем переменную $uploadfile именем файла, и соответственно проверку загрузился файл или нет. А во вьюшке upload - светим результат.&nbsp;&nbsp; &nbsp;<br />\nИнформация о файле - колличество строк + размер, тоже выполняется в uploadAction, а во вьюшке upload светится.&nbsp;&nbsp; &nbsp;<br />\n//*************************uploadAction, upload*********************************************//</p>\n\n<p>//*************************listAction*********************************************//<br />\nВ listAction нужно передавать $params[&#39;text&#39;] - содержимое файла, обратиться к файлу загруженному на сервер.<br />\n//*************************listAction*********************************************//&nbsp;&nbsp; &nbsp;<br />\n/******************************************************class IndexController(FileProcessController)****************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="route.yml" name="route.yml"></a><br />\n/*********************************конфиг-файл(route.yml)************************************************************************************************************************/</p>\n\n<p>1. Создай роут конфиг-файл типа(yml). положи его в config.<br />\nindex: &nbsp; &nbsp; [/, IndexController.indexAction]<br />\nupload: &nbsp;[/upload, IndexController.uploadAction]<br />\n...</p>\n\n<p>это весь route.yml<br />\n&nbsp;index: &nbsp;[/, IndexController.indexAction]<br />\n&nbsp;upload: [/upload, IndexController.uploadAction]<br />\n&nbsp;list: &nbsp; [/list, IndexController.listAction]</p>\n\n<p>В примерах чаще config.yml-<br />\n&nbsp;&nbsp; &nbsp;config.yml - это общий конфиг чаще всего, для роутинга используется свой, так и понятнее.<br />\n&nbsp;&nbsp; &nbsp;</p>\n\n<p>еще момент по поводу конфига:<br />\n&nbsp;&nbsp; &nbsp;index: &nbsp;[/, IndexController.indexAction]<br />\n&nbsp;&nbsp; &nbsp;upload: [/upload, IndexController.uploadAction]<br />\n&nbsp;&nbsp; &nbsp;list: &nbsp; [/list, IndexController.listAction]<br />\nлучше использовать неймспейс в задании контроллера:<br />\n&nbsp;&nbsp; &nbsp;index: &nbsp;[/, src\\Controller\\IndexController.indexAction]<br />\n&nbsp;&nbsp; &nbsp;upload: [/upload, src\\Controller\\IndexController.uploadAction]<br />\n&nbsp;&nbsp; &nbsp;list: &nbsp; [/list, src\\Controller\\IndexController.listAction]<br />\n/**<br />\n*&nbsp;&nbsp; &nbsp; $param = [&#39;/&#39;, &#39;src\\Controller\\IndexController.indexAction&#39;]<br />\n*/<br />\n&nbsp;&nbsp; &nbsp;public function process($param){&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$controllerData = &nbsp; implode(&#39;.&#39;,$param[1] );<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$controller = new $controllerData[0](); // идентично $controller = new src\\Controller\\IndexController()<br />\n&nbsp;&nbsp; &nbsp;}<br />\nВ процессе отделить класс (src\\Controller\\IndexController) и его метод (indexAction) и создавать $controller = new src\\Controller\\IndexController()&nbsp;&nbsp; &nbsp;<br />\n/*********************************конфиг файл(route.yml)************************************************************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="Route" name="Route"></a><br />\n/********************************************************************************class Route************************************************************************************/<br />\n1. Создай класс Rout c методом __construct(array $config) - $config - данные из файла.<br />\nmatch($url) - созвращает array(&#39;controller&#39; =&gt; &#39;контроллер&#39;, &#39;action&#39; =&gt; &#39;метод&#39;).<br />\nУ роута 2 метода , конструктор, и match($url).<br />\nКонструктор - &nbsp;__construct(array $config) получает уже массив. match($url) - &nbsp;возвращает array(&#39;controller&#39; =&gt; &#39;контроллер&#39;, &#39;action&#39; =&gt; &#39;метод&#39;).</p>\n\n<p><br />\n2. Тебе нужно вычитать route.yml преобразовать его в масив и передать в конструктор роутера.<br />\nДальше написать метод match($url) который тебе вернет нужные параметры. По ним получить контроллер и метод и выполнить их.</p>\n\n<p><br />\nclass Route(){</p>\n\n<p>&nbsp;&nbsp; &nbsp;public function __construct(array $config){//__construct(array $config) получает уже массив<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- $config - данные из файла &nbsp; &nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;public function match($url){// &nbsp;метод match($url) который тебе вернет нужные параметры.&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- возвращает array(&#39;controller&#39; =&gt; &#39;контроллер&#39;, &#39;action&#39; =&gt; &#39;метод&#39;)&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;}</p>\n\n<p>}</p>\n\n<p><br />\nprotected &nbsp;readRouteConfig($file) //!!!protected!!!<br />\n&nbsp;&nbsp; &nbsp;<br />\nreadRouteConfig($file) - читает файл конфиг.</p>\n\n<p>getRoute() возвращает объект Route.</p>\n\n<p>$routeParam = $route-&gt;match($url); - результат [/upload, IndexController.uploadAction] или просто IndexController.uploadAction.<br />\nРезультат массив &nbsp;типа [/upload, IndexController.uploadAction].</p>\n\n<p><br />\nгеттер &nbsp;получается:<br />\n&nbsp;&nbsp; &nbsp;public function getRoute(){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return $this-&gt;route;<br />\n&nbsp;&nbsp; &nbsp;}</p>\n\n<p>Route.php<br />\n1. в нём тебе нужно добавить свойство $routeParams.</p>\n\n<p>2. в конструкторе -<br />\n&nbsp;&nbsp; &nbsp;public function __construct(array $config){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this-&gt;routeParams = $config; &nbsp; &nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;}<br />\narray $config в конструкторе - это распарсенные данные из route.yml.</p>\n\n<p>3. match<br />\n&nbsp;&nbsp; &nbsp;public function match($url){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;перебирает $this-&gt;routeParams и находим нужный нам параметр.<br />\n&nbsp;&nbsp; &nbsp;}<br />\n//************Route.php**********//<br />\n/********************************************************************************class Route{}************************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="Kernel" name="Kernel"></a><br />\n/********************************************************************************class Кernel{}************************************************************************************/<br />\nКласс kernel - синглетон. В котром загружаешь конфиг, передаёшь в роутер, получаешь данные по контроллеру,<br />\n&nbsp;&nbsp; &nbsp;выполняешь метод нужного контроллера, получаешь результат выполнения.<br />\nKernel<br />\nrender($params)<br />\n{<br />\n&nbsp; &nbsp;выпоняет отображение результата работы&nbsp;<br />\n}<br />\nВычитать route.yml преобразовать его в масив и передать в конструктор роутера - это выполняется в кернеле, Kernel.<br />\nВычитку сделай в кернеле метод, readConfigs.</p>\n\n<p><br />\nВместо render надо readConfigs, или это совсем другой метод ещё?<br />\n&nbsp;&nbsp; &nbsp;-Не, render будет и этот метод выдает результат работы на экран.<br />\n&nbsp;&nbsp; &nbsp;<br />\n/***так правильно??? Kernel***/<br />\n&nbsp;Kernel - Класс kernel синглетон. в котром загружаешь конфиг, передаешь в роутер, получаешь данные по контроллеру,<br />\nвыполняешь метод нужного контроллера получаешь результат выполнения, ( - это вобщем).<br />\nТебе нужно вычитать route.yml преобразовать его в масив и передать в конструктор роутера,<br />\nвычитку сделай в кернеле метод, readConfigs.<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;Kernel&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;readConfigs($params){//readConfigs замени на readRouteConfig()<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;вычитать route.yml преобразовать его в массив и передать в конструктор роутера.<br />\n&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;render($params){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;выпоняет отображение результата работы &nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;}</p>\n\n<p>readConfigs замени на readRouteConfig().</p>\n\n<p>В конструктор route передавать в другом методе init например<br />\n&quot;вернуть&quot;, &nbsp;в отдельном методе init &nbsp;например<br />\n&nbsp;&nbsp; &nbsp;поэтому ты с роут начинал ...</p>\n\n<p>class Kernel<br />\n{<br />\n&nbsp; &nbsp; public function init() {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; $params = $this-&gt;readRouteConfig();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; $route = new Route($params);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<br />\n&nbsp; &nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;public function readRouteConfig($params){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;вычитать route.yml преобразовать его в масив и передать в конструктор роутера<br />\n&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;public function render($params){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;выпоняет отображение результата работы &nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;}<br />\n}</p>\n\n<p>public function init($pathes) $pathes - array(&#39;route&#39; =&gt; путь, ...)<br />\n&nbsp;&nbsp; &nbsp;Еще будут конфиги, на будущее.</p>\n\n<p>public function init($pathes) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; $routeConfig = $this-&gt;readRouteConfig($pathes[&#39;route&#39;]);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; $this-&gt;route = new Route($routeConfig);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; // ...<br />\n&nbsp; &nbsp; &nbsp;}</p>\n\n<p>Путь к файлу передаём -&nbsp;<br />\n&nbsp;&nbsp; &nbsp;public function init($pathes) $pathes - array(&#39;route&#39; =&gt; путь, ...)</p>\n\n<p>Массив $pathes заполняем в app.php&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;$pathes[route] = &#39;C:\\apache\\localhost\\www\\ModeraTest\\config\\route.yml&#39;;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;<br />\nKernel -это синглетон конструктор там приватный и пустой.</p>\n\n<p>В кернеле еще process($param) - в нём будет отрабатывать контроллер.&nbsp;&nbsp; &nbsp;</p>\n\n<p>match($url); - &nbsp;метод класса Kernel.<br />\n&nbsp;&nbsp; &nbsp;Можно сделать обертку и спрятать это в него.&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$route = $kernel-&gt;getRoute();<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$routeParam = $route-&gt;match($url);</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public function match($url){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return $this-&gt;getRoute()-&gt;match($url)<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\n\n<p>&nbsp;&nbsp; &nbsp;match($url) - должен вернуть массив, который подходит под указанный урл,<br />\n&nbsp;&nbsp; &nbsp;если урл:<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;modera.loc/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- [/, IndexController.indexAction]<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;modera.loc/upload - [/upload, IndexController.uploadAction]<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;modera.loc/list &nbsp; &nbsp; &nbsp; &nbsp; - [/list, IndexController.listAction]<br />\n&nbsp;&nbsp; &nbsp;вот что делает матч<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[&#39;/&#39;, &#39;IndexController.indexAction&#39;] == array(&#39;/&#39;, &#39;IndexController.indexAction&#39;)<br />\n&nbsp;&nbsp; &nbsp;я везде использую новый способ задания массива, он короче и читабельнее</p>\n\n<p>геттер - получается:<br />\n&nbsp;&nbsp; &nbsp;public function getRoute(){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return $this-&gt;route;<br />\n&nbsp;&nbsp; &nbsp;}</p>\n\n<p>&nbsp;&nbsp; &nbsp;match<br />\n&nbsp;&nbsp; &nbsp;public function match($url){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;перебирает $this-&gt;routeParams и находим нужный нам параметр<br />\n&nbsp;&nbsp; &nbsp;}&nbsp;&nbsp; &nbsp;</p>\n\n<p><br />\n&nbsp;&nbsp; &nbsp;public function init($file) {<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$routeConfig = $this-&gt;readRouteConfig($file); &nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$route = $this-&gt;route = new Route($routeConfig);<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return $route;<br />\n&nbsp; &nbsp; }</p>\n\n<p>&nbsp;&nbsp; &nbsp;public function init($file) {<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$routeConfig = $this-&gt;readRouteConfig($file); &nbsp; &nbsp;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$this-&gt;route = new Route($routeConfig);<br />\n&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;!!!ненужен ретурн!!!<br />\ninit - инициализирует ничего не возвращает.<br />\nМы инициализировали объект Route и передали распарсенный массив,<br />\nпосле init() в Kernel у тебя есть заполненный Route.</p>\n\n<p>process Kernel.php возвращает данные для render, нужно выполнить метод контроллера и получить от него данные и вернуть.<br />\n&nbsp; &nbsp;$file = DIR . &#39;/../config/route.yml&#39;;<br />\nDIR . &#39;/../config/route.yml&#39; - это самый лучший вариант, на сервере Linux по другому работать не будет.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n/********************************************************************************class Кernel{}************************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="Composer" name="Composer"></a><br />\n/********************************************************************************COMPOSER****************************************************************************************/<br />\nComposer<br />\n&nbsp;&nbsp; &nbsp;- с помощью него будем актуальные либы ставить.</p>\n\n<p>1. composer.json - ложешь в корень проекта. Вот его содержание:<br />\n&nbsp;&nbsp; &nbsp;{<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&quot;require&quot;: {<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&quot;symfony/Yaml&quot;: &quot;*&quot;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;}<br />\n2. устанавливаешь composer https://getcomposer.org/doc/00-intro.md (global install)<br />\n3. в проекте, в консоли(в cmd) composer install.<br />\n4. подключаешь в арр&nbsp;<br />\n&nbsp;&nbsp; &nbsp;require __DIR__ . &#39;/../vendor/autoload.php&#39;;<br />\n&nbsp;&nbsp; &nbsp;use \\Symfony\\Component\\Yaml\\Yaml;<br />\n5. пример чтения yaml<br />\n&nbsp;&nbsp; &nbsp;require __DIR__ . &#39;/../vendor/autoload.php&#39;;<br />\n&nbsp;&nbsp; &nbsp;use \\Symfony\\Component\\Yaml\\Yaml;</p>\n\n<p>&nbsp;&nbsp; &nbsp;$array = Yaml::parse(file_get_contents(__DIR__ . &#39;/../config/route.yml&#39;));</p>\n\n<p>&nbsp;&nbsp; &nbsp;var_dump($array);</p>\n\n<p>composer - самый основной инструмент по подключению либ, его используют все фреймворки.</p>\n\n<p>//***************************Установка COMPOSER**************************//</p>\n\n<p>1. composer.json - ложишь в корень проекта -<br />\n&nbsp;&nbsp; &nbsp;корень проекта это ModeraTest.<br />\n&nbsp;&nbsp; &nbsp;<br />\nРасширение OpenSSL отсутствует, что означает, что безопасной передачи HTTPS невозможно .<br />\nЕсли возможно, вы должны включить его или перекомпилировать PHP с опцией --with- OpenSSL<br />\n-&nbsp;&nbsp; &nbsp;библиотеку надо было подключить.<br />\n&nbsp; &nbsp; 2. устанавливаешь composer https://getcomposer.org/doc/00-intro.md (global install) , подсветился сайт - https://getcomposer.org/<br />\n&nbsp; &nbsp; 3. В проекте , в консоли composer install - &nbsp;в &nbsp;cmd &nbsp;нужно набрать?<br />\n&nbsp;&nbsp; &nbsp; &nbsp; В проекте -<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;в cmd перейти в C:\\apache\\localhost\\www\\ModeraTest &nbsp;и запустить composer install<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;cd C:\\apache\\localhost\\www\\ModeraTest<br />\ncomposer &nbsp;прочитает composer.json и установит компоненты в папку vendor.</p>\n\n<p>папка вендор появилась в C:\\apache\\localhost\\www\\ModeraTest<br />\n&nbsp;&nbsp; &nbsp;</p>\n\n<p>если в app.php написать только это получишь распарсенный массив:<br />\n&nbsp;&nbsp; &nbsp;require __DIR__ . &#39;/../vendor/autoload.php&#39;;<br />\n&nbsp;&nbsp; &nbsp;use \\Symfony\\Component\\Yaml\\Yaml;</p>\n\n<p>&nbsp;&nbsp; &nbsp;$array = Yaml::parse(file_get_contents(__DIR__ . &#39;/../config/route.yml&#39;));</p>\n\n<p>&nbsp;&nbsp; &nbsp;var_dump($array);</p>\n\n<p>получилось:<br />\narray(3) { [&quot;index&quot;]=&gt; array(2) { [0]=&gt; string(1) &quot;/&quot; [1]=&gt; string(27) &quot;IndexController.indexAction&quot; } [&quot;upload&quot;]=&gt; array(2) { [0]=&gt; string(7) &quot;/upload&quot; [1]=&gt; string(28) &quot;IndexController.uploadAction&quot; } [&quot;list&quot;]=&gt; array(2) { [0]=&gt; string(5) &quot;/list&quot; [1]=&gt; string(26) &quot;IndexController.listAction&quot; } }<br />\n//***************************Установка COMPOSER**************************//<br />\n/********************************************************************************COMPOSER****************************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="SPL_AUTOLOAD" name="SPL_AUTOLOAD"></a><br />\n/*******************************************************************************SPL_AUTOLOAD*************************************************************************************/<br />\nМы, получается, уходим от ParserYaml, что скачивали ранее.</p>\n\n<p><br />\n//*************************************//<br />\nРазбирайся с spl, чтоб классы подключались<br />\n&nbsp;&nbsp; &nbsp;var_dump(spl_autoload_functions());<br />\nСделай в примере и ты увидишь как компосер загрузил классы с вендоров это тебе покажет что загружено.<br />\n//*************************************//<br />\nspl_autoload<br />\nУ тебя не подгружаются классы.</p>\n\n<p>Если сделать такой app.php, скрипт заработает?<br />\n&nbsp;&nbsp; &nbsp;&lt;?php<br />\n&nbsp;&nbsp; &nbsp;require __DIR__ . &#39;/../vendor/autoload.php&#39;;</p>\n\n<p>&nbsp;&nbsp; &nbsp;use \\app\\Kernel\\Kernel;<br />\n&nbsp;&nbsp; &nbsp;spl_autoload_extensions(&quot;.php&quot;);<br />\n&nbsp;&nbsp; &nbsp;spl_autoload_register();</p>\n\n<p>&nbsp;&nbsp; &nbsp;$kernel = Kernel::getInstance();</p>\n\n<p>Fatal error: Class &#39;app\\Kernel\\Kernel&#39; not found in /var/www/max/public/app.php on line 11</p>\n\n<p><br />\nuse \\app\\Kernel\\Kernel;<br />\nspl_autoload_register(<br />\n&nbsp; &nbsp; function($class){<br />\n&nbsp; &nbsp; &nbsp; &nbsp; $path = realpath (__DIR__ . &#39;/../&#39;.str_replace(&quot;\\\\&quot;,&quot;/&quot;,$class.&quot;.php&quot;));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; require_once $path;<br />\n&nbsp; &nbsp; }<br />\n);<br />\n$kernel = Kernel::getInstance();</p>\n\n<p>Нужно написать класс или функцию, по автозагрузке классов\\<br />\nНужно прочитать и понимать как работает spl_autoload_...</p>\n\n<p>В примере читал ранее, думал этого достаточно:<br />\n&nbsp;&nbsp; &nbsp;spl_autoload_extensions(&quot;.php&quot;); - подключает все классы php.<br />\n&nbsp;&nbsp; &nbsp;spl_autoload_register();</p>\n\n<p><br />\nИнклуды в файлах кроме app.php или классов autoloader.php - хардкод,&nbsp;<br />\nИнклуды и реквайреды.</p>\n\n<p>Разбери работу этого кода и пойми для себя как это работает. Что не понимаешь спрашивай, но конкретику<br />\n&nbsp;&nbsp; &nbsp;spl_autoload_register(<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;function($class){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$path = realpath (__DIR__ . &#39;/../&#39;.str_replace(&quot;\\\\&quot;,&quot;/&quot;,$class.&quot;.php&quot;));<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;require_once $path;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;);</p>\n\n<p>Это замыкание (тоже почитай, любимый вопрос на собеседовании):&nbsp;<br />\n&nbsp;&nbsp; &nbsp;function($class){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$path = realpath (__DIR__ . &#39;/../&#39;.str_replace(&quot;\\\\&quot;,&quot;/&quot;,$class.&quot;.php&quot;));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; require_once $path;<br />\n&nbsp; &nbsp; }</p>\n\n<p><br />\nМы можем использовать замыкания, то есть сохранять переменные из области видимости при создании функции.//+ любимый вопрос на собеседовании(ещё один... :)))<br />\n&nbsp;&nbsp; &nbsp;use \\app\\Kernel\\Kernel;<br />\n&nbsp;&nbsp; &nbsp;spl_autoload_register(<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;function($class){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$path = realpath (__DIR__ . &#39;/../&#39;.str_replace(&quot;\\\\&quot;,&quot;/&quot;,$class.&quot;.php&quot;));//realpath &mdash; Возвращает канонизированный абсолютный путь к файлу,раскрывает символический<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;require_once $path;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;);<br />\n$kernel = Kernel::getInstance();</p>\n\n<p>ошибка на реквайреде когда разкомментирую &nbsp;init()-<br />\n&nbsp;&nbsp; &nbsp;require_once() [function.require]: Failed opening required &#39;&#39; (include_path=&#39;.;C:\\php\\pear&#39;) in C:\\apache\\localhost\\www\\ModeraTest\\public\\app.php on line 9</p>\n\n<p>Поставить проверку на существования файла в<br />\n&nbsp;&nbsp; &nbsp;spl_autoload_register(<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;function($class){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$path = realpath (DIR . &#39;/../&#39;.str_replace(&quot;\\\\&quot;,&quot;/&quot;,$class.&quot;.php&quot;));//realpath &mdash; Возвращает канонизированный абсолютный путь к файлу, раскрывает символический<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;require_once $path;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\n&nbsp;&nbsp; &nbsp;);<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- if( file_exists...<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;и, если нет - выводить и смотреть путь.<br />\n/*******************************************************************************SPL_AUTOLOAD*************************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="schema" name="schema"></a><br />\n/*******************************************************************************СХЕМА действий***********************************************************************************/<br />\nВ render мы должны передавать файл, типа render($route),<br />\n&nbsp;а &nbsp;$route приходит из<br />\n&nbsp;&nbsp; &nbsp;init(){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;....<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return $rout;<br />\n&nbsp;&nbsp; &nbsp;}</p>\n\n<p>&nbsp;&nbsp; &nbsp;<br />\nСХЕМА действий:<br />\n***************************************************<br />\n$kernel-&gt;init();<br />\n$route = $kernel-&gt;getRoute();<br />\n$routeParam = $route-&gt;match($url);<br />\n$controllerParams = $kernel-&gt;process($routeParams);<br />\n$kernel-&gt;render($routeParams, $controllerParams); // или объединить в один массив [&#39;routeParam&#39; =&gt; $routeParam, &#39;controllerParams&#39;=&gt; $controllerParams]<br />\n***************************************************<br />\n-это содержимое app.php</p>\n\n<p>$kernel-&gt;getRoute();</p>\n\n<p><br />\n$routeParam = $route-&gt;match($url);<br />\n$url - это относительный урл типа /, /upload, /list</p>\n\n<p>index: &nbsp;[/, IndexController.indexAction]<br />\nupload: [/upload, IndexController.uploadAction]<br />\nlist: &nbsp; [/list, IndexController.listAction]</p>\n\n<p>это рез-тат $route = $kernel-&gt;getRoute(); ?<br />\n&nbsp;&nbsp; &nbsp;[(/upload) - урл, (IndexController.uploadAction) - $routeParam]</p>\n\n<p>$routeParam = $route-&gt;match($url); - результат [/upload, IndexController.uploadAction] или просто IndexController.uploadAction</p>\n\n<p>***************************************************<br />\n$kernel-&gt;init();<br />\n$route = $kernel-&gt;getRoute();<br />\n$routeParam = $route-&gt;match($url);<br />\n$controllerParams = $kernel-&gt;process($routeParams);<br />\n$kernel-&gt;render($routeParams, $controllerParams); // или объединить в один массив [&#39;routeParam&#39; =&gt; $routeParam, &#39;controllerParams&#39;=&gt; $controllerParams]<br />\n***************************************************<br />\n-это содержимое app.php</p>\n\n<p><br />\n$url = $_SERVER[&#39;REQUEST_URI&#39;];<br />\n...<br />\n$routeParam = $route-&gt;match($url);</p>\n\n<p><br />\nprotected &nbsp;readRouteConfig($file) //!!!protected!!!<br />\n&nbsp;&nbsp; &nbsp;<br />\nreadRouteConfig($file) - читает файл конфиг.</p>\n\n<p>getRoute() возвращает объект Route.</p>\n\n<p>$routeParam = $route-&gt;match($url); - результат [/upload, IndexController.uploadAction] или просто IndexController.uploadAction<br />\nрезультат массив типа [/upload, IndexController.uploadAction].</p>\n\n<p>match($url); - уже метод класса Kernel.<br />\n&nbsp;&nbsp; &nbsp;можно сделать обертку и спрятать это в него&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$route = $kernel-&gt;getRoute();<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$routeParam = $route-&gt;match($url);</p>\n\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public function match($url){<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return $this-&gt;getRoute()-&gt;match($url)<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\n\n<p>&nbsp;&nbsp; &nbsp;match($url) - должен вернуть массив, который подходит под указанный урл,<br />\n&nbsp;&nbsp; &nbsp;если урл:<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;modera.loc/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- [/, IndexController.indexAction]<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;modera.loc/upload - [/upload, IndexController.uploadAction]<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;modera.loc/list &nbsp; &nbsp; &nbsp; &nbsp; - [/list, IndexController.listAction]<br />\n&nbsp;&nbsp; &nbsp;вот что делает матч<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[&#39;/&#39;, &#39;IndexController.indexAction&#39;] == array(&#39;/&#39;, &#39;IndexController.indexAction&#39;)<br />\n&nbsp;&nbsp; &nbsp;я везде использую новый способ задания массива, он короче и читабельнее.</p>\n\n<p>&nbsp;</p>\n\n<p>url &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| modera_test.loc/index &nbsp; | modera_test.loc/upload &nbsp; &nbsp;| modera_test.loc/list<br />\ncontroller &nbsp; &nbsp; | Index &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | какой определишь &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| какой определишь<br />\nmethod &nbsp; &nbsp; &nbsp; &nbsp; | indexAction() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | uploadAction() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| listAction()<br />\nview &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | index.php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | upload.php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| list.php</p>\n\n<p><br />\nПо каждой из ссылок должна отработать цепочка из таблицы, эту таблицу можно дополнять новыми урлами, но функцию process и render после написания&nbsp;<br />\nты больше не трогаешь и вообще kernel не трогаешь, настраиваешь все конфигами и если нужно пишешь контроллеры с вьюшками.</p>\n\n<p>если ты поставишь:&nbsp;</p>\n\n<p>url &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| modera_test.loc/index &nbsp; | modera_test.loc/upload &nbsp; &nbsp;| modera_test.loc/list<br />\ncontroller &nbsp; &nbsp; | Index &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | FileProcessController &nbsp; &nbsp; | FileProcessController<br />\nmethod &nbsp; &nbsp; &nbsp; &nbsp; | indexAction() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | uploadAction() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| listAction()<br />\nview &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | index.php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | upload.php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| list.php</p>\n\n<p>то &nbsp;FileProcessController ты возмешь из $routeParams при заходе на урлу modera_test.loc/upload</p>\n\n<p><br />\nВ кернеле есть &nbsp;&nbsp; &nbsp;$route = $this-&gt;route = new Route($routeConfig);<br />\n&nbsp;&nbsp; &nbsp;есть явно лишняя переменная $route и нет объявленного свойства класса $this-&gt;route<br />\nВ кернеле объяви свойство класса route и $this-&gt;route = new Route($routeConfig); достаточно.</p>\n\n<p>public function getRoute(){//возвращает объект Route &nbsp;<br />\n&nbsp; return $route = $this-&gt;route; &nbsp;<br />\n&nbsp; &nbsp; }<br />\n&nbsp;&nbsp; &nbsp;то же,тут тоже индуский код, зачем тебе $route?<br />\n&nbsp;&nbsp; &nbsp;- return $this-&gt;route; достаточно.<br />\n/*******************************************************************************СХЕМА действий***********************************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;||&nbsp;<a href="#end">вконец</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="РЕФАКТОРИНГ" name="РЕФАКТОРИНГ"></a><br />\n/*******************************************************************************РЕФАКТОРИНГ(IndexController)*********************************************************************/<br />\nДерево строится с N ветвями. Логика написана должна быть без привязки к конкретным ветвям, $mp3, $tv, ...</p>\n\n<p>Собрать ветки-<br />\n1. Отсортировать массив с данными, так чтоб корневые ветви были первые.<br />\n2. Создать основной узел $goods = new C\\CompositeGoods(0,&quot;goods&quot;), через фабрику.<br />\n&nbsp;&nbsp; &nbsp;$goods = $factory-&gt;create(array(&#39;nodeId&#39;=&gt;0, &#39;nodeName&#39;=&gt;&#39;goods&#39;));<br />\n&nbsp;&nbsp; &nbsp;<br />\n<a id="Iterator" name="Iterator"></a>&nbsp;&nbsp; &nbsp;<br />\n/*******************************************************************************class Iterator*********************************************************************/&nbsp;&nbsp; &nbsp;<br />\n3. Написать класс итератор, который может перебирать дерево и находить узлы по id.</p>\n\n<p>interface IteratorInterface<br />\n{<br />\n&nbsp; &nbsp;/**<br />\n&nbsp; &nbsp;* Seek to position&nbsp;<br />\n&nbsp; &nbsp;*/<br />\n&nbsp; &nbsp;public function seek($index);&nbsp;</p>\n\n<p>&nbsp; &nbsp;/**<br />\n&nbsp; &nbsp;* Return current composite element entry&nbsp;<br />\n&nbsp; &nbsp;*/<br />\n&nbsp; &nbsp;public function current();<br />\n&nbsp;&nbsp;<br />\n&nbsp; &nbsp;/**<br />\n&nbsp; &nbsp;* Return current composite element key&nbsp;<br />\n&nbsp; &nbsp;*/<br />\n&nbsp; &nbsp;public function key();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />\n}</p>\n\n<p>Iterator implements IteratorInterface<br />\nа RootCompositeGoods extends CompositeGoods.</p>\n\n<p><br />\ndisplay - не рекурсия, веерное выполнение, как домино падает.</p>\n\n<p>рекурсия &mdash; вызов функции (процедуры) из неё же самой, в дисплее ты не вызовешь дисплей внутри дисплея, ты вызываешь дислей у другого объекта, а это не тот же дисплей.<br />\nТут нет рекурсивности</p>\n\n<p>http://www.softtime.ru/bookphp/gl5_4.php</p>\n\n<p>Метод seek() - не рекурсивный и в него передается только $position, рекурсивный метод внутри него (find()).</p>\n\n<p>/**<br />\n* Этот метод рекурсивно ищет объект Composite в&nbsp;<br />\n* @param array &nbsp; &nbsp;$data<br />\n* @param integer $index<br />\n*<br />\n* @return null|Composit<br />\n*/<br />\nprotected function find(array $data, $index);</p>\n\n<p><br />\nfind() - &nbsp;находится &nbsp;в seek.<br />\n&nbsp;&nbsp; &nbsp;<br />\nnext() не имеет параметров.</p>\n\n<p>/**********************************************************************************/<br />\npublic function find(array $dataArray, $position) - не публичный<br />\narray $dataArray - массив объектов должен быть, а не многомерный массив.<br />\nпонятно, ты просто кидаешь туда не композицию(Composite), а массив.<br />\n/**********************************************************************************/<br />\n/*******************************************************************************class Iterator*********************************************************************/&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="RootCompositeGoods" name="RootCompositeGoods"></a><br />\n/*******************************************************************************class RootCompositeGoods***********************************************************/&nbsp;&nbsp; &nbsp;<br />\nclass RootCompositeGoods {<br />\n&nbsp;&nbsp; &nbsp;protected $iterator;<br />\n&nbsp;&nbsp; &nbsp;public function getIterator()<br />\n&nbsp;&nbsp; &nbsp;<br />\nВ нём (class RootCompositeGoods) наследуется все что было у CompositeGoods + getIterator().<br />\nА модификатор доступа должен быть protected $iterator; &nbsp;-protected, можно и privat.<br />\n&nbsp;<br />\n&nbsp;<br />\nНужно отнаследоваться от CompositeGoods и написать класс RootCompositeGoods. Это класс в себе должен содержать итератор.<br />\ncreateRoot должен содержаться в классе GoodsFactory, в классе GoodsFactory в методе createRoot обращаюсь к RootCompositeGoods,<br />\n&nbsp;&nbsp; &nbsp;return new C\\RootCompositeGoods<br />\n/*******************************************************************************class RootCompositeGoods***********************************************************/&nbsp;&nbsp; &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;&gt;&gt;&nbsp;</p>\n\n<p><br />\nПолучилось собрать дерево -(добавил в find (int) в условие).<br />\nСмести все индексы на 1, чтоб рут стал 1, а остальные после него,(для этого нужно сместить и parentId сместить на 1)- пологаю дерево не должно собраться.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Всё работает. Пробовал 2 варианта.<br />\nНасильное приведение типов, что-то скрыло, ты же нигде не использовал === для сравнения.(?ВОПРОС).&nbsp;&nbsp; &nbsp;<br />\n/*******************************************************************************РЕФАКТОРИНГ(IndexController)*********************************************************************/</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;<a href="#top">Вначало</a>&nbsp;&gt;&gt;</p>\n\n<p><a id="end" name="end"></a></p>\n\n<p><a href="#all">/***********************************************ОБЩИЕ РЕКОМЕНДАЦИИ.***********************************************************************************/</a><br />\n<a href="#File">/*************************************************class File{}******************************************************************************************************/</a><br />\n<a href="#TextFile">/*************************************************class TextFile**************************************************************************************************/</a><br />\n<a href="#TextParser">/*************************************************class TextParser***********************************************************************************************/</a><br />\n<a href="#CompositeGoods">/*************************************************class CompositeGoods***************************************************************************************/</a><br />\n<a href="#GoodsFactory">/*************************************************class GoodsFactory*******************************************************************************************/</a><br />\n<a href="#ФОРМА">/*************************************************ФОРМА********************************************************************************************************/</a><br />\n<a href="#IndexController">/*************************************************class IndexController(FileProcessController)***************************************************************/</a><br />\n<a href="#route.yml">/*************************************************конфиг-файл(route.yml)*************************************************************************************/</a><br />\n<a href="#Route">/*************************************************class Route****************************************************************************************************/</a><br />\n<a href="#Kernel">/*************************************************class Кernel{}**************************************************************************************************/</a><br />\n<a href="#Composer">/*************************************************COMPOSER**************************************************************************************************/</a><br />\n<a href="#SPL_AUTOLOAD">/*************************************************SPL_AUTOLOAD*********************************************************************************************/</a><br />\n<a href="#schema">/*************************************************СХЕМА действий********************************************************************************************/</a><br />\n<a href="#РЕФАКТОРИНГ">/*************************************************РЕФАКТОРИНГ(IndexController)***************************************************************************/</a><br />\n<a href="#Iterator">/******************************************************class Iterator*********************************************************************************************/</a><br />\n<a href="#RootCompositeGoods">/******************************************************class RootCompositeGoods****************************************************************************/</a></p>\n');        DB::table('tests')->insert(['id' => 8, 'active' => 1, 'title' => '6. Рекомендации', 'slug' => 'recommends', 'image' => 'yhQFXgOynO5EP4Iq15Q7jWAp2dav4fGG.png', 'content' => $content, 'created_at' => '2015-08-26 07:20:58', 'updated_at' => '2015-08-28 03:41:26']);    }}class UsersTableSeeder extends Seeder {    /**     * Run the database seeds.     *     * @return void     */    public function run()    {        DB::table('users')->insert(['id' => 1, 'name' => 'admin', 'email' => 'admin@admin.admin', 'password' => '$2y$10$lKZzJn3rVVcgalLH3e72de7SBYbyF3rPLOCebKkgX6OAnZb.j3gEm', 'remember_token' => 'HyKLxkJOu2uvLniFdSPNF5a2ecQ9gDNd9zf4mOO68Z0MDQgS737idAyuRVtM', 'created_at' => '2015-07-21 10:31:41', 'updated_at' => '2015-07-21 13:20:29']);    }}